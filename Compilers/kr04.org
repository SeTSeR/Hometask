#+LATEX_HEADER:\usepackage[T2A]{fontenc}
#+LATEX_HEADER:\usepackage[utf8]{inputenc}
#+LATEX_HEADER:\usepackage{minted}
#+LATEX_HEADER:\usepackage{wrapfig}

#+TITLE: Контрольная работа №4
#+DATE: \today
#+AUTHOR: Макаров Сергей, группа 427
#+EMAIL: setser200018@gmail.com
#+OPTIONS: toc:nil

* Задача
Удалить мёртвый код в следующей программе:
#+ATTR_LATEX: :height 300px
[[./code.png]]
\pagebreak
** Решение
CFG для приведённой программы:
#+begin_src dot :file cfg4.png
  digraph G {
      Entry -> start;
      start -> if;
      start -> else;
      if -> loop;
      loop -> cnt;
      loop -> endloop;
      cnt -> loop;
      endloop -> Exit;
      else -> Exit;
      post -> endloop;
      end -> end;
      end -> post;
  }
#+end_src

#+ATTR_LATEX: :height 400px
#+RESULTS:
[[file:cfg4.png]]

Теперь рассмотрим операции, которые будут помечены на каждой итерации. На первой итерации будут помечены операции ~return t0~ в блоке endloop и ~return t1~ в блоке ~else~, поскольку эти операции задают возвращаемое значение функции. $WorkList = \{(return t0), (return t1)\}$

На второй итерации будут помечены:
1. ~t1 <- +, n, m~ из блока else, т. к. она задаёт определение для t1.
2. ~t0 <- *, t0, 2~ из блока post и ~t0 <- +, t0, t1~ из блока if, а так же ~t0 <- *, t0, n~ из блока cnt, так как они задают определение для t0, достигающее инструкции ~return t0~.
3. $RDF(endloop) = \{start\}$ и $RDF(else) = \emptyset$, поэтому помечается также инструкция ветвления в конце блока start.
4. $WorkList = \{(t1 <- +, n, m), (t0 <- *, t0, 2), (t0 <- *, t0, n), (ifTrue n = m goto else)\}$

На третьей итерации будут помечены инструкции:
1. ~param n~ и ~param m~, так как они задают определения для m и n, нужные для вычисления ~t1 <- +, n, m~. Кроме того, они же нужны для вычисления ветвления в блоке start, которое было помечено ранее.
2. Инструкция ~t0 <- *, t0, 2~ новых пометок не привносит, так как нет достигающих этой инструкции определений переменной t0.
3. Для вычисления инструкции ~t0 <- *, t0, n~ из блока cnt нужны определения переменных ~t0~ и ~n~, вследствие чего помечается инструкция ~n <- -, n, 1~ из того же блока. Единственное неучтённое определение t0 предоставляется этой же инструкцией.
4. Также помечаются инструкции ~t0 <- 1~ и ~t1 <- *, t1, t1~ из блока if, так как они предоставляют определения переменных t0 и t1, необходимые для инструкции ~t0 <- +, t0, t1~.
5. $RDF(start) = \emptyset, RDF(if) = \{start\}, RDF(cnt) = \{loop\}$, поэтому так же нужно пометить ветвление в конце start, благо оно уже было помечено, так что в WorkList оно не добавляется. Также помечается ветвление в конце loop.
6. $WorkList = \{(param n), (param m), (t0 <- 1), (t1 <- *, t1, t1), (n <- -, n, 1), (ifTrue n > 1 goto endLoop)\}$.

Наконец, на последней итерации будет помечена инструкция ~t1 <- *, t0, t0~ из блока if, поскольку она предоставляет определение t1, необходимое для инструкции ~t1 <- * t1, t1~. Все остальные инструкции из WorkList новых пометок не провоцируют.

В результате удаления непомеченных инструкций и ветвлений получим код:
#+begin_src text
  start:
        param n
        param m
        ifTrue n = m goto else
  if:
        t0 <- 1
        t1 <- *, t0, t0
        t1 <- *, t1, t1
        t0 <- +, t0, t1
  loop:
        ifTrue n > 1 goto endloop
  cnt:
        t0 <- *, t0, n
        n <- -, n, 1
        goto loop
  post:
        t0 <- *, t0, 2
  endloop:
        return t0
  else:
        t1 <- +, n, m
        return t1
  end:
        goto post
#+end_src
Заметим, что блоки end и post являются недостижимыми. Ветвление в конце блока end не было помечено, поэтому оно было заменено на переход к ближайшему полезному постдоминатору, т. е. post.
