#+LATEX_HEADER:\usepackage[T2A]{fontenc}
#+LATEX_HEADER:\usepackage[utf8]{inputenc}
#+LATEX_HEADER:\usepackage[english,russian]{babel}

#+TITLE: Описание семантики машинных команд для абстрактной интерпретации
#+DATE: \today
#+AUTHOR: Макаров Сергей
#+EMAIL: smakarov@ispras.ru
#+STARTUP: beamer
#+LANGUAGE: ru
#+LATEX_CLASS: beamer
#+OPTIONS: toc:nil H:2 num:t
#+BEAMER_THEME: Frankfurt
#+BEAMER_INNER_THEME: rounded
#+BEAMER_FRAME_LEVEL: 2

* Введение
** Мотивация
+ В современных решениях для анализа бинарного кода одни и те же задачи, в частности, декодирование команд и трансляция их в промежуточное представление, решаются каждый раз заново, для каждой частной задачи.
+ В рамках проекта Glassfrog предлагается унифицированный подход для решения задач декодирования процессорных команд, трансляции их в промежуточное представление и анализа полученного представления.
+ Для описания форматов файлов, формата и семантики машинных команд предлагается использование внутреннего языка спецификаций с расчётом на то, что поддерживать такие спецификации проще, чем код.
+ В качестве решения для задач анализа кода предлагается подход, основанный на теории абстрактной интерпретации.
** Glassfrog
[[./glassfrog.png]]
* Промежуточное представление
** Pivot 2
Анализ кода производится над внутренним промежуточным представлением Pivot 2. Рассмотрим
основные структурные элементы этого представления:
+ Адресные пространства
+ Операции
+ Временные переменные
+ Операторы
+ Базовые блоки
+ Фрагменты
** Адресные пространства и регистры
Адресные пространства описывают память, с которой могут работать команды процессора. Могут
быть локальными или удалёнными. Пример описания адресного пространства:
#+begin_src text
space registers: local[u8];
space iomem: remote[i8] ~> i4;
#+end_src

На уровне спецификаций также есть *регистры* -- ссылки на ячейки адресного пространства
определённого размера:
#+begin_src text
register x1: u32 from registers;
#+end_src
** Операции
Операции принимают на вход набор битовых векторов и возвращают набор битовых векторов. Для
операций должны быть выполнены следующие требования:
1. Нет побочных эффектов, все входные и выходные данные -- формальные параметры.
2. Все входы влияют на все выходы.
Пример описания операции:
#+begin_src text
op add<T: Integer>(a: T, b: T) -> (default result: T,
                                   cf: bool, of: bool)
where
    result = 'add(a, b);
    cf = 'adduo(a, b);
    of = 'addso(a, b);
#+end_src
** Базовые блоки
Базовый блок представляет собой непрерывную с точки зрения потока управления последовательность
операторов. Передача данных между блоками осуществляется посредством групп временных переменных.
Вместо \phi-функции используется следующий механизм: из каждого блока есть два выхода, "истинный"
и "ложный". Выбор выхода зависит от значения специальной управляющей временной переменной
размера 1. Каждому выходу назначается группа переменных, передаваемых в этом направлении.
Аналогично, для "принимающего" блока задаётся группа входных переменных.
** Базовые блоки
Пример графа потока управления, соответствующего простейшему условному переходу:
#+begin_src dot :file cfg.png :exports results
digraph G {
    node[shape=box,label=""];
    a [label="v1 := 1, v2 := 0"]
    b [label="v3 := 2"]
    c [label="v3 := 1"]
    d
    a -> b[label="v1 истина"];
    a -> c[label="v1 ложь"];
    b -> d[label="v0 ложь, передаётся v3"]
    c -> d[label="v0 ложь, передаётся v3"]
}
#+end_src

#+RESULTS:
[[file:cfg.png]]
** Фрагменты (уровень Pivot 2)
Фрагмент является самой крупной структурной единицей промежуточного представления. Логически
фрагмент -- это граф, вершинами которого являются базовые блоки, с одним входом и одним выходом.
Входные параметры фрагмента совпадают с входной группой входного блока. Входной блок может
иметь пустую группу входных переменных. Результатом работы фрагмента является
группа временных переменных, возвращаемая выходным блоком.
** Функции (уровень спецификаций)
Пример спецификации для функции:
#+begin_src text
fn g(a: u8, b: u8) -> (result: bits(13))
{
        let result: bits(13) = if <a, b>[0:0] {
            <a, b>[1:13]
        } else {
            <a, b>[2:14]
        };
}
#+end_src
* Устройство компилятора
** Общая схема работы
1. Парсинг файла, получение дерева разбора.
2. Построение AST и таблицы имён из дерева разбора.
3. Заполнение таблиц трейтов и синонимов типов.
4. Заполнение таблицы констант и нахождение значений некоторых констант.
5. Вычисление значений остальных констант и построение констант pivot.
6. Построение таблиц адресных пространств и регистров и их трансляция.
8. Построение, мономорфизация и трансляция операций.
9. Построение, мономорфизация и трансляция функций.
* Заключение
** Ближайшие задачи
1. Стабилизация языка спецификаций
2. Переделка компилятора с учётом изменений в языке, упрощение его архитектуры
3. Интеграция компилятора спецификациями с другими компонентами системы, в частности, с декодером и анализатором.
4. Оптимизации получаемого pivot-кода
** Ссылки
[[https://ispranproceedings.elpub.ru/jour/article/view/1257]]
[[https://ispranproceedings.elpub.ru/jour/article/view/1120]]
[[https://www.di.ens.fr/~cousot/COUSOTpapers/POPL77.shtml]]
[[https://github.com/NationalSecurityAgency/ghidra]]
