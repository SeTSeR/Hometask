#+LATEX_HEADER:\usepackage{amsmath}
#+LATEX_HEADER:\usepackage{esint}
#+LATEX_HEADER:\usepackage[T2A]{fontenc}
#+LATEX_HEADER:\usepackage[utf8]{inputenc}
#+LATEX_HEADER:\usepackage[english,russian]{babel}
#+LATEX_HEADER:\usepackage{mathtools}
#+LATEX_HEADER:\usepackage{amsthm}

#+TITLE: Использование динамического слайсинга и обратного выполнения при отладке
#+DATE: \today
#+AUTHOR: Макаров Сергей
#+EMAIL: smakarov@ispras.ru
#+STARTUP: beamer
#+LANGUAGE: ru
#+LATEX_CLASS: beamer
#+OPTIONS: toc:nil H:2 num:t
#+BEAMER_THEME: Frankfurt
#+BEAMER_INNER_THEME: rounded
#+BEAMER_FRAME_LEVEL: 2

* Введение
** Порядок отладки
1. Найти проблему в поведении программы и сформулировать её в терминах её состояния
2. Найти код, который влияет на значение данной переменной в данный момент времени
3. Восстановить состояние программы на момент выполнения интересующего нас кода
* Динамический слайсинг
+ *Статический слайс программы по отношению к данной переменной* - набор строк программы, потенциально влияющих на значение данной переменной при произвольных входных данных
+ Поскольку статический слайсинг рассматривает все возможные варианты исполнения, он может включать слишком много лишних строк
+ *Динамический слайс* по отношению к данной переменной по Корелю и Ласки - программа, являющаяся подмножеством данной программы, такая, что её выполнение равносильно выполнению оригинальной программы с точки зрения данной переменной
+ С точки зрения отладки исполняемость слайса не нужна, поэтому можно оставить только код, влияющий на значение переменной
** Локальный анализ
Возможны три варианта проявления ошибки:
1. Значение некоторого выражения $exp$ в точке $L$ некорректно
2. Управление попало в точку $L$, куда оно не должно было попасть
3. Управление не попало в точку $L$
** Случай 1
1. В выражении $exp$ вычисляется некорректная функция от входа. Если это так, ошибка найдена
2. Значение хотя бы одной из переменных(например, переменной $var$), входящих в $exp$, некорректно. В этом случае нужно найти последнюю точку, в которой переменной $var$ присваивалось значение. Эту точку будем называть достигающим определением
Когда мы нашли достигающее определение $R$, возможны ещё два случая:
1. Значение выражения $exp'$, которое вычисляется в $R$, некорректно. Получаем снова случай 1
2. $R$ - неверное достигающее определение для $var$
** Случай 1
В последнем случае есть ещё четыре варианта:
1. Управление не должно было попасть в $R$, что возвращает нас к случаю 2
2. Нет нужного определения для $var$. В этом случае мы нашли ошибку
3. Выполнение дошло до $R$, но пошло не по тому пути, и не дошло до корректного определения $R'$. Получаем случай 3
4. $R$ не должно быть в программе в принципе. В этом случае мы нашли ошибку - лишнее присваивание
** Случай 2
Если управление не должно было дойти до точки $L$, возможны два случая
1. $L$ вложено в условие $pred$. Здесь возможны случаи:
  1. Управление не должно было дойти до $pred$. Тогда мы получаем случай 2 для $pred$.
  2. Управление должно было дойти до $pred$, но не до $L$. Здесь есть ещё два случая:
     1. Условие было вычислено неверно, тогда мы получаем случай 1.
     2. Пропущено условие на пути от $pred$ до $L$, которое бы предотвратило попадание в $L$.
2. $L$ не вложено ни в какое условие. В этом случае мы нашли ошибку, так как должно быть условие, которое предотвратит попадание в $L$.
** Случай 3
Если управление не дошло до $L$, это означает, что $L$ непосредственно заключено в условие $pred$, из-за которого управление не попадает в $L$.
Возможны три варианта:
1. Управление не дошло и до $pred$. Получаем случай 3 для $pred$
2. Управление дошло до $pred$, но не дошло до $L$. Это означает, что условие $pred$ было вычислено некорректно, поэтому получаем случай 1 для $pred$
3. $pred$ не должно было быть в программе в принципе. Тогда мы нашли ошибку - лишнее условие
** Глобальный анализ
На больших программах техника, приведённая выше, может быть слишком трудоёмкой, особенно если место возникновения ошибки далеко от места её проявления. Для упрощения работы
можно соединить множество успешных переходов в один.
** Глобальный анализ
*** Случай 1
Если выражение $exp$ в точке $L$ принимает некорректное значение, возможны варианты:
+ Результат некоторого некорректного присваивания $A$ по достигающим присваиваниям попадает в $exp$
+ Присваивание, результат которого должен был попасть в $exp$, не выполнилось
+ Присваивание, результат которого должен был попасть в $exp$, отсутствует
+ Одного из присваиваний, которые повлияли на результат $exp$, не должно быть в программе
+ Одно из присваиваний, результат которых влияет на $expr$, выполнилось неверное количество раз
** Глобальный анализ
*** Случай 2
Если управление по ошибке достигло точки $L$, возможны два случая:
+ Одно из условий, содержащих $L$, было вычислено неверно
+ Пропущено одно из условий, окружающих $L$
*** Случай 3
Если управление не дошло до точки $L$, возможны, опять же, два случая:
+ Одно из содержащих $L$ условий было вычислено неверно
+ Одно из содержащих $L$ условий лишнее
** Глобальный анализ
*Динамическим слайсом по данным* по отношению к данному выражению, точке и тесту будем называть транзитивное замыкание достигающих изменений переменных, учавствующих в $exp$.

Если известно, что значение выражения $exp$ неверно, используя слайс по данным для этого выражения, можно найти пропущенное или лишнее присваивание, либо выяснить, что было
выполнено не то присваивание. Если ни один из этих случаев не имеет места, это означает, что одно из присваиваний, влияющих на $exp$, выполнилось неверное количество раз.
** Глобальный анализ
*Динамическим слайсом по управлению* по отношению к данному выражению, точке и тесту будем называть транзитивное замыкание включающих данную точку условий.

Если слайс по данным полезен при разборе случая 1, то слайс по управлению полезен в случаях 2 и 3, когда нужно найти все условия, включающие данную точку программы.

Объединение строк, входящих в слайс по данным и слайс по управлению даёт нам всю необходимую информацию для нахождения ошибки. Это объединение мы и будем называть
*динамическим слайсом программы* по отношению к данному выражению, точке программы и тесту. Таким образом, динамический слайс включает в себя все строки, влияющие
на значение данного выражения в данной точке.
* Обратное выполнение
** Обратное выполнение
 После того, как мы нашли преполагаемое место ошибки, необходимо восстановить состояние программы в этом месте. В традиционных отладчиках для этого необходимо установить
 точку останова и запустить выполнение с самого начала. В SPYDER был реализован механизм "выполнения в обратную сторону": шаг при таком выполнении отменяет результат последнего
 выполненного шага. Для этого SPYDER записывает путь выполнения и переменные, изменённые на каждом шаге.
* Заключение
** Выводы
+ Для того, чтобы применять технику слайсинга, нужно описать проблему в терминах некорректных данных и ошибок потока управления, что само по себе может быть нетривиальной задачи и требовать отладки
+ Некоторые зависимости по данным могут быть не видны в слайсе. Например, зависимость условия цикла от кода в его теле.
+ Обратное выполнение может отменить не все побочные эффекты программы, в общем случае нужна помощь ОС, например, в случае системных вызовов.
+ Тем не менее, с учётом описанных ограничений связка динамического слайсинга с обратным выполнением может значительно упростить отладку.
** Ссылки
 1. [[https://spaf.cerias.purdue.edu/Students/spyder.html][SPYDER]]
 2. [[https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html][Reverse execution in GDB]]
 3. [[https://rr-project.org/][RR project]]
 4. [[https://eax.me/reverse-debugging/][Reverse debugging с помощью GDB и RR]]
 5. [[https://github.com/pbadenski/halik][Halik - отладчик для Java с поддержкой time-travel]]
