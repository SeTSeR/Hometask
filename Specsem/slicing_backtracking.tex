% Created 2019-10-21 Mon 16:02
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{esint}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{mathtools}
\usepackage{amsthm}
\usetheme{Frankfurt}
\useinnertheme{rounded}
\author{Макаров Сергей}
\date{\today}
\title{Использование динамического слайсинга и обратного выполнения при отладке}
\hypersetup{
 pdfauthor={Макаров Сергей},
 pdftitle={Использование динамического слайсинга и обратного выполнения при отладке},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={Russian}}
\begin{document}

\maketitle

\section{Введение}
\label{sec:orgdb93891}
\begin{frame}[label={sec:orgc63c627}]{Порядок отладки}
\begin{enumerate}
\item Найти проблему в поведении программы и сформулировать её в терминах её состояния
\item Найти код, который влияет на значение данной переменной в данный момент времени
\item Восстановить состояние программы на момент выполнения интересующего нас кода
\end{enumerate}
\end{frame}
\section{Динамический слайсинг}
\label{sec:org95f06cf}
\begin{itemize}
\item \alert{Статический слайс программы по отношению к данной переменной} - набор строк программы, потенциально влияющих на значение данной переменной при произвольных входных данных
\item Поскольку статический слайсинг рассматривает все возможные варианты исполнения, он может включать слишком много лишних строк
\item \alert{Динамический слайс} по отношению к данной переменной по Корелю и Ласки - программа, являющаяся подмножеством данной программы, такая, что её выполнение равносильно выполнению оригинальной программы с точки зрения данной переменной
\item С точки зрения отладки исполняемость слайса не нужна, поэтому можно оставить только код, влияющий на значение переменной
\end{itemize}
\begin{frame}[label={sec:orgdd84b00}]{Локальный анализ}
Возможны три варианта проявления ошибки:
\begin{enumerate}
\item Значение некоторого выражения \(exp\) в точке \(L\) некорректно
\item Управление попало в точку \(L\), куда оно не должно было попасть
\item Управление не попало в точку \(L\)
\end{enumerate}
\end{frame}
\begin{frame}[label={sec:orgd98de93}]{Случай 1}
\begin{enumerate}
\item В выражении \(exp\) вычисляется некорректная функция от входа. Если это так, ошибка найдена
\item Значение хотя бы одной из переменных(например, переменной \(var\)), входящих в \(exp\), некорректно. В этом случае нужно найти последнюю точку, в которой переменной \(var\) присваивалось значение. Эту точку будем называть достигающим определением
\end{enumerate}
Когда мы нашли достигающее определение \(R\), возможны ещё два случая:
\begin{enumerate}
\item Значение выражения \(exp'\), которое вычисляется в \(R\), некорректно. Получаем снова случай 1
\item \(R\) - неверное достигающее определение для \(var\)
\end{enumerate}
\end{frame}
\begin{frame}[label={sec:org6c56435}]{Случай 1}
В последнем случае есть ещё четыре варианта:
\begin{enumerate}
\item Управление не должно было попасть в \(R\), что возвращает нас к случаю 2
\item Нет нужного определения для \(var\). В этом случае мы нашли ошибку
\item Выполнение дошло до \(R\), но пошло не по тому пути, и не дошло до корректного определения \(R'\). Получаем случай 3
\item \(R\) не должно быть в программе в принципе. В этом случае мы нашли ошибку - лишнее присваивание
\end{enumerate}
\end{frame}
\begin{frame}[label={sec:org862a843}]{Случай 2}
Если управление не должно было дойти до точки \(L\), возможны два случая
\begin{enumerate}
\item \(L\) вложено в условие \(pred\). Здесь возможны случаи:
\begin{enumerate}
\item Управление не должно было дойти до \(pred\). Тогда мы получаем случай 2 для \(pred\).
\item Управление должно было дойти до \(pred\), но не до \(L\). Здесь есть ещё два случая:
\begin{enumerate}
\item Условие было вычислено неверно, тогда мы получаем случай 1.
\item Пропущено условие на пути от \(pred\) до \(L\), которое бы предотвратило попадание в \(L\).
\end{enumerate}
\end{enumerate}
\item \(L\) не вложено ни в какое условие. В этом случае мы нашли ошибку, так как должно быть условие, которое предотвратит попадание в \(L\).
\end{enumerate}
\end{frame}
\begin{frame}[label={sec:orge87ff64}]{Случай 3}
Если управление не дошло до \(L\), это означает, что \(L\) непосредственно заключено в условие \(pred\), из-за которого управление не попадает в \(L\).
Возможны три варианта:
\begin{enumerate}
\item Управление не дошло и до \(pred\). Получаем случай 3 для \(pred\)
\item Управление дошло до \(pred\), но не дошло до \(L\). Это означает, что условие \(pred\) было вычислено некорректно, поэтому получаем случай 1 для \(pred\)
\item \(pred\) не должно было быть в программе в принципе. Тогда мы нашли ошибку - лишнее условие
\end{enumerate}
\end{frame}
\begin{frame}[label={sec:org635bb0d}]{Глобальный анализ}
На больших программах техника, приведённая выше, может быть слишком трудоёмкой, особенно если место возникновения ошибки далеко от места её проявления. Для упрощения работы
можно соединить множество успешных переходов в один.
\end{frame}
\begin{frame}[label={sec:org07c0cc0}]{Глобальный анализ}
\begin{block}{Случай 1}
Если выражение \(exp\) в точке \(L\) принимает некорректное значение, возможны варианты:
\begin{itemize}
\item Результат некоторого некорректного присваивания \(A\) по достигающим присваиваниям попадает в \(exp\)
\item Присваивание, результат которого должен был попасть в \(exp\), не выполнилось
\item Присваивание, результат которого должен был попасть в \(exp\), отсутствует
\item Одного из присваиваний, которые повлияли на результат \(exp\), не должно быть в программе
\item Одно из присваиваний, результат которых влияет на \(expr\), выполнилось неверное количество раз
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org77d8b79}]{Глобальный анализ}
\begin{block}{Случай 2}
Если управление по ошибке достигло точки \(L\), возможны два случая:
\begin{itemize}
\item Одно из условий, содержащих \(L\), было вычислено неверно
\item Пропущено одно из условий, окружающих \(L\)
\end{itemize}
\end{block}
\begin{block}{Случай 3}
Если управление не дошло до точки \(L\), возможны, опять же, два случая:
\begin{itemize}
\item Одно из содержащих \(L\) условий было вычислено неверно
\item Одно из содержащих \(L\) условий лишнее
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org1250810}]{Глобальный анализ}
\alert{Динамическим слайсом по данным} по отношению к данному выражению, точке и тесту будем называть транзитивное замыкание достигающих изменений переменных, учавствующих в \(exp\).

Если известно, что значение выражения \(exp\) неверно, используя слайс по данным для этого выражения, можно найти пропущенное или лишнее присваивание, либо выяснить, что было
выполнено не то присваивание. Если ни один из этих случаев не имеет места, это означает, что одно из присваиваний, влияющих на \(exp\), выполнилось неверное количество раз.
\end{frame}
\begin{frame}[label={sec:orgc6d8191}]{Глобальный анализ}
\alert{Динамическим слайсом по управлению} по отношению к данному выражению, точке и тесту будем называть транзитивное замыкание включающих данную точку условий.

Если слайс по данным полезен при разборе случая 1, то слайс по управлению полезен в случаях 2 и 3, когда нужно найти все условия, включающие данную точку программы.

Объединение строк, входящих в слайс по данным и слайс по управлению даёт нам всю необходимую информацию для нахождения ошибки. Это объединение мы и будем называть
\alert{динамическим слайсом программы} по отношению к данному выражению, точке программы и тесту. Таким образом, динамический слайс включает в себя все строки, влияющие
на значение данного выражения в данной точке.
\end{frame}
\section{Обратное выполнение}
\label{sec:org1bfb74c}
\begin{frame}[label={sec:orgcbd0a86}]{Обратное выполнение}
После того, как мы нашли преполагаемое место ошибки, необходимо восстановить состояние программы в этом месте. В традиционных отладчиках для этого необходимо установить
точку останова и запустить выполнение с самого начала. В SPYDER был реализован механизм "выполнения в обратную сторону": шаг при таком выполнении отменяет результат последнего
выполненного шага. Для этого SPYDER записывает путь выполнения и переменные, изменённые на каждом шаге.
\end{frame}
\section{Заключение}
\label{sec:org3c63a38}
\begin{frame}[label={sec:org3e1c801}]{Выводы}
\begin{itemize}
\item Для того, чтобы применять технику слайсинга, нужно описать проблему в терминах некорректных данных и ошибок потока управления, что само по себе может быть нетривиальной задачи и требовать отладки
\item Некоторые зависимости по данным могут быть не видны в слайсе. Например, зависимость условия цикла от кода в его теле.
\item Обратное выполнение может отменить не все побочные эффекты программы, в общем случае нужна помощь ОС, например, в случае системных вызовов.
\item Тем не менее, с учётом описанных ограничений связка динамического слайсинга с обратным выполнением может значительно упростить отладку.
\end{itemize}
\end{frame}
\section{Ссылки}
\label{sec:orgaa511dc}
\begin{frame}[label={sec:orgece74a4}]{Ссылки}
\begin{enumerate}
\item \href{https://spaf.cerias.purdue.edu/Students/spyder.html}{SPYDER}
\item \href{https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html}{Reverse execution in GDB}
\item \href{https://rr-project.org/}{RR project}
\item \href{https://eax.me/reverse-debugging/}{Reverse debugging с помощью GDB и RR}
\item \href{https://github.com/pbadenski/halik}{Halik - отладчик для Java с поддержкой time-travel}
\end{enumerate}
\end{frame}
\end{document}
