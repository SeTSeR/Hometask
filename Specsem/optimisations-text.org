#+LATEX_HEADER:\usepackage[T2A]{fontenc}
#+LATEX_HEADER:\usepackage[utf8]{inputenc}

#+TITLE: Оптимизация промежуточного представления для абстрактной интерпретации
#+DATE: \today
#+AUTHOR: Макаров Сергей
#+EMAIL: smakarov@ispras.ru
#+LANGUAGE: ru
#+OPTIONS: toc:nil H:2 num:t

* Введение
** Мотивация
+ В современных решениях для анализа бинарного кода одни и те же задачи, в частности, декодирование команд и трансляция их в промежуточное представление, решаются каждый раз заново, для каждой частной задачи.
+ В рамках проекта Glassfrog предлагается унифицированный подход для решения задач декодирования процессорных команд, трансляции их в промежуточное представление и анализа полученного представления.
+ Для описания форматов файлов, формата и семантики машинных команд предлагается использование внутреннего языка спецификаций с расчётом на то, что поддерживать такие спецификации проще, чем код.
+ В качестве решения для задач анализа кода предлагается подход, основанный на теории абстрактной интерпретации.
** Glassfrog
[[./glassfrog.png]]
** Постановка задачи оптимизации
Поскольку сложность абстрактной интерпретации напрямую зависит от размера кода, имеет смысл перед абстрактной интерпретацией провести некоторые оптимизации, чтобы уменьшить размер промежуточного представления. Есть две возможности для оптимизации сгенерированного кода:
1. Оптимизация при компиляции спецификаций.
2. Оптимизация при построении промежуточного представления.
** Структура Pivot2 IR
+ Модули
+ Адресные пространства
+ Константы
+ Базовые блоки
+ Фрагменты
** Фрагменты
+ Фрагмент представляет собой гамак из базовых блоков.
+ Фрагмент представляется в SSA форме. Передача переменных по рёбрам CFG осуществляется с помощью входных и выходных переменных базовых блоков.
+ Переменные базовых блоков имеют областью видимости весь фрагмент.
+ Базовые блоки представляют собой последовательность операторов. Всего есть 7 операторов: ~APPLY~, ~CALL~, ~INIT~, ~LOAD~, ~MIX~, ~SLICE~ и ~STORE~.
* Оптимизация спецификаций
** Общая структура оптимизаций
Трансляция спецификаций в IR происходит один раз, далее для анализа используются уже скомпилированные спецификации команд. Это позволяет провести основные трансформации на этом этапе.
1. Свёртка и продвижение констант проводятся на этапе семантического анализа.
2. Удаление лишних подвыражений и операторов ~LOAD/STORE~ производится на этапе приведения IR к SSA-форме.
3. Сворачивание цепочек операторов ~SLICE~ проводится отдельным проходом.
4. Наконец, финальным проходом проводится удаление мёртвого кода и упрощение графа потока управления.
** Свёртка и продвижение констант
Свёртка и продвижение констант производится на этапе семантического анализа. Для этого каждый узел AST, соответствующий выражению, снабжается атрибутом "значение". Эти атрибуты затем вычисляются отдельным проходом по AST. Если для узла AST значение уже вычислено, код для его вычисления не генерируется, и для соответствующей конструкции генерируется оператор ~INIT~.
** Построение SSA
1. Обходятся все базовые блоки в CFG, переименовываются переменные в каждом операторе: входные переменные заменяются соответствующими им определениями, для выходных переменных формируются новые номера.
2. Устраняются лишние передачи переменных по рёбрам CFG, внесённые первой фазой.
К полезным свойствам этого алгоритма относится то, что этот алгоритм позволяет применять локальные оптимизации во время построения SSA-формы. Более того, поскольку алгоритм не привязан к порядку обхода, это позволяет использовать оптимизации на расширенных базовых блоках. Кроме того, используя таблицу определений для переменных, можно также удалить все операторы ~MIX~.
** Удаление лишних подвыражений
Локальный Value Numbering:

Каждому оператору, вычисляющему некоторое значение (~APPLY~, ~INIT~, ~SLICE~), сопоставляется «выражение-значение». Поддерживается хэш-таблица, где ключами являются выражения-значения, а значениями -- переменные, в которых записаны результаты соответствующих операторов. При обнаружении оператора, соответствующее которому выражение-значение уже присутствует в таблице, оператор удаляется, а для его выходной переменной добавляется связывание с переменной, в которой это выражение было вычислено.
** Удаление лишних LOAD и STORE
Локальный Load/Store elimination:

Идея оптимизации состоит в том, что все чтения из памяти, в которую записано уже известное значение, можно исключить, используя это значение. Аналогично, можно удалить последующие записи значения в ту же память. Для этого поддерживается хэш-таблица, в которой ключами являются «выражения загрузки», содержащие адрес ячейки пространства, ссылку на адресное пространство, размер, и endianness доступа, а значениями являются переменные. Избыточные чтения и записи обнаруживаются и удаляются аналогично предыдущей оптимизации.
** Расширенные базовые блоки
Расширенным базовым блоком называется максимальный по включению подграф графа потока управления с одним входным блоком и возможно несколькими выходными, такой, что у каждого его блока, за исключением может быть входного, не более одного предка.

Методы оптимизации, описанные в предыдущих слайдах, можно обобщить для расширенных базовых блоков. Для этого нужны две вещи: построить подходящий порядок обхода CFG, и исправить соответствующие методы.
** Обход расширенных базовых блоков
Поддерживается массив «входных» блоков расширенных базовых блоков. На первом этапе он состоит только из входного блока. Затем на каждом этапе CFG обходится в глубину до блоков, у которых больше одного предка. Каждый такой блок добавляется в список «входных» блоков, если его ещё там нет. Как только обход EBB заканчивается, происходит переход к следующему, пока все EBB не будут пройдены.
** Обобщение методов оптимизации
Заметим, что каждое выражение, описанное в блоке, доступно так же во всех блоках EBB, которые будут посещены при обходе EBB после захода в этот блок, но до выхода из него. 

Это позволяет предложить следующее обобщение для алгоритмов оптимизации:

Будем хранить таблицы «выражений-значений» и «выражений-загрузок» не в виде плоских таблиц, а в виде стека, каждый уровень которого представляет набор значений, которые доступны на данном «уровне» EBB. Расширенные базовые блоки обходятся в глубину, каждый EBB обходится по отдельности в глубину. При входе в базовый блок на стек загружается новый уровень, при выходе этот уровень сбрасывается со стека.
** Сворачивание цепочек операторов SLICE
Рассмотрим дерево, вершинами которого являются переменные, а ребро между переменными ~u~ и ~v~ существует тогда и только тогда, когда во фрагменте существует оператор ~SLICE~, входом которого является переменная ~u~, а выходом -- переменная ~v~. В этом случае задача схлопывания цепочек операторов ~SLICE~ сводится к задаче «сжатия» ветвей в дереве.
** Сжатие ветвей
1. Обход графа, нахождение всех цепей.
2. Разбиение подцепей на цепи, в которых промежуточные вершины не используются.
3. Сворачивание цепей в одно ребро.
** Удаление мёртвого кода и упрощение CFG
Удаление мёртвого кода производится с помощью классического Mark&Sweep алгоритма. На первой фазе помечаются все важные операторы и переходы, на второй фазе непомеченные операторы удаляются.

Упрощение CFG достигается посредством систематического применения четырёх трансформаций:
1. Замена ветвления, оба ребра которого переходят в один блок, на безусловный переход.
2. Удаление пустого блока.
3. Слияние двух подряд идущих блоков.
4. Перенос ветвления из пустого блока к предку.
* Оптимизация анализируемого кода
** Абстрактная интерпретация
В терминах Glassfrog интерпретация это абстрактное состояние и набор передаточных функций, определяющих, как изменяется состояние при выполнении каждого оператора и при переходе по ребру CFG. Для задач анализа потока данных интерпретация должна быть монотонна, т. е. множество её состояний должно образовывать решётку. Вычисление результата абстрактной интерпретации по фрагменту происходит с помощью исполнителя.
** Глобальное удаление избыточного кода
С помощью абстрактной интерпретации находятся множества доступных выражений и содержимое памяти в начале каждого блока. Следующий проход заменяет лишние вычисления, чтения и записи на операторы ~MIX~, используя эту информацию. Наконец, последним проходом удаляются операторы ~MIX~.
1. Передаточная функция для операторов ~APPLY~, ~INIT~ и ~SLICE~ добавляет соответствующее выражение как доступное.
2. Передаточная функция для оператора ~STORE~ обновляет содержимое соответствующей ячейки памяти.
3. Передаточная функция для оператора ~CALL~ сбрасывает наборы доступных выражений и содержимое памяти.
* Заключение
** Заключение
 + Были реализованы два пакета набора оптимизаций: для оптимизации спецификаций процессорных архитектур и для оптимизации анализируемого представления.
 + Замеров того, насколько реализованные оптимизации повышают скорость анализа, не производилось, поскольку соответствующая инфраструктура ещё не до конца реализована, и не набрана достаточная база примеров.
 + В дальнейшем планируется реализовать на основе инфраструктуры поиск утечек и пополнить базу примеров и спецификаций.
** Источники
+ https://ispranproceedings.elpub.ru/jour/article/view/1120 \\
+ K. Cooper, L. Torczon, Engineering a Compiler 2nd Edition \\
+ https://compilers.cs.uni-saarland.de/papers/bbhlmz13cc.pdf \\
+ http://www.di.ens.fr/~cousot/COUSOTpapers/POPL77.shtml \\
+ https://ispranproceedings.elpub.ru/jour/article/view/1257
