% Created 2020-03-05 Thu 15:24
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{esint}
\usepackage[english, russian]{babel}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage[top=0.8in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}
\def\zall{\setcounter{lem}{0}\setcounter{cnsqnc}{0}\setcounter{th}{0}\setcounter{Cmt}{0}\setcounter{equation}{0}\setcounter{stnmt}{0}}
\newcounter{lem}\setcounter{lem}{0}
\def\lm{\par\smallskip\refstepcounter{lem}\textbf{\arabic{lem}}}
\newtheorem*{Lemma}{Лемма \lm}
\newcounter{th}\setcounter{th}{0}
\def\th{\par\smallskip\refstepcounter{th}\textbf{\arabic{th}}}
\newtheorem*{Theorem}{Теорема \th}
\newcounter{cnsqnc}\setcounter{cnsqnc}{0}
\def\cnsqnc{\par\smallskip\refstepcounter{cnsqnc}\textbf{\arabic{cnsqnc}}}
\newtheorem*{Consequence}{Следствие \cnsqnc}
\newcounter{Cmt}\setcounter{Cmt}{0}
\def\cmt{\par\smallskip\refstepcounter{Cmt}\textbf{\arabic{Cmt}}}
\newtheorem*{Note}{Замечание \cmt}
\newcounter{stnmt}\setcounter{stnmt}{0}
\def\st{\par\smallskip\refstepcounter{stnmt}\textbf{\arabic{stnmt}}}
\newtheorem*{Statement}{Утверждение \st}
\author{Sergey Makarov}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Sergey Makarov},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}


\section{Структура курса}
\label{sec:orgba99d8f}
\begin{itemize}
\item Введение в теорию сложности
\item Линейное программирование
\item Методы непрерывной оптимизации
\item Методы решения переборных задач
\end{itemize}
\section{Литература}
\label{sec:orgaea3125}
\begin{enumerate}
\item Новикова Н. М. "Дискретные и непрерывные задачи оптимизации"
\item М. Гэри, Д. Джонсон "Вычислительные машины и труднорешаемые задачи"
\item Х. Пападимитриу, К. Стайглиц "Комбинаторные оптимизации"
\item \url{http://www.ccas.ru/depart/malashen/53kmsu.htm}
\end{enumerate}
\section{Введение в теорию сложности}
\label{sec:org21a760b}
\textbf{Массовая задача} $\Pi = \{I\}$, где $I$ - \textbf{индивидуальная задача}. Массовая задача определяется:
\begin{enumerate}
\item списком параметров
\item требованиями к решению
\end{enumerate}
\subsection{Задача коммивояжёра}
\label{sec:org9cd92ef}
Задан взвешенный ориентированный граф: вершины и матрицы. Нужно найти маршрут через все
вершины графа минимального веса.
\begin{equation*}
\text{Найти } \pi^0\{1, \ldots, n\} \rightarrow \pi(1), \ldots, \pi(n), \\
\pi^0 \in \operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1}))\right\}
\end{equation*}
Всего порядка \(n!\) маршрутов.

Задача \textbf{бездомного} коммивояжёра - нужно найти гамильтонов путь в графе. Эта задача имеет ту
же сложность.

Задача построения \textbf{остовного дерева} минимального веса.

С точки зрения сложности задачи делятся на два класса: полиномиальная или экспоненциальная
зависимость затрат на решения от длины входа.
\subsection{Задачи распознавания свойств}
\label{sec:orgd8e565b}
Задачи, в которых требования к решению выражаются предикатом. В этих терминах задача коммивояжёра
формулируется так:
\begin{equation*}
\{n, \{d_{ij} = d(c_i, c_j)\}, B\}
\end{equation*}
\begin{equation*}
\exists? \pi: \left\{\operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1})\right\}\right\} \leq B
\end{equation*}
С помощью бинарного поиска задача распознавания свойств сводится к оптимизационной задаче,
класс задачи при этом не меняется.
\textbf{Кодировка} массовой задачи \(\Pi\) включает в себя:
\begin{enumerate}
\item Алфавит \(\Sigma\) - конечное множество символов.
\item \(\Sigma^*\) - множество слов в алфавите \(\Sigma\). Длину слова \(\sigma\) будем обозначать \(|\sigma|\).
\item \textbf{Функция кодирования} \(e: \{I\} \Rightarrow \Sigma^*, e(I) = \sigma\), обладающая свойствами:
\begin{itemize}
\item Инъективность(однозначность): \(\forall I_1 \neq I_2 e(I_1) \neq e(I_2)\).
\item Полиноминальность кодирования и декодирования: \(\exists p(\cdot)\text{( --- полином )} \forall I \in \Pi: |e(I)| \leq p(|I|), |e^{-1}(\sigma)| \leq p(|\sigma|)\)
\item Неизбыточность: \(\forall e'\), обладающей предыдущими двумя свойствами \(\exists p(\cdot): |e(I)| \leq p(|e'(I)|)\) на наборе задач, для которого \(\forall m \exists I |e(I)| \leq m\).
\end{itemize}
\end{enumerate}
\subsection{Задача 1}
\label{sec:org824e70f}
Задача построения остовного дерева минимального веса(+задача распознавания свойства):
\begin{equation*}
n, d_{ij} \in \mathbb{N}_0
\end{equation*}
Предложить неизбыточную кодировку входа, найти длину входа и сравнить её с оценкой для задачи
коммивояжёра:
\begin{equation*}
n + \lceil\log_2B\rceil + \max_{ij}\lceil\log_2d_{ij}\rceil
\end{equation*}
\subsection{Язык задачи}
\label{sec:org673fb77}
Помимо кодировки с задачей связывается \textbf{язык}: \(\alpha(\Pi, e) = \{\sigma \in \Sigma^* | \sigma = e(I), I \in Y(\Pi)\}\),
где \(Y(\Pi)\) -- это множество индивидуальных задач, на которых ответ является истиной.

Алгоритм - программа для ДМТ, по кодировке задачи выдающая ответ. Алгоритм \(A\) \textbf{применим} к \(\sigma \in \Sigma^*\),
если на этом слове он останавливается. Алгоритм \(A\) \textbf{принимает} слово \(\sigma\), если он
останавливается на нём и выдаёт истинный ответ.
\begin{equation*}
\alpha(A) = \{\sigma \in \Sigma^* | \Sigma \text{-- алфавит } A, A(\sigma) = true\}
\end{equation*}
Алгоритм A \textbf{решает} задачу \(\Pi\) с кодировкой \(e\), если \(\forall \sigma \in \Sigma^* A\)
останавливается и \(\alpha(A) = \alpha(\Pi, e)\).

\textbf{Функция временной сложности} алгоритма \(A\) решения \(\Pi\) называется функция \(T_A(\cdot)\), обладающая
свойствами:
\begin{enumerate}
\item \(\forall I \in \Pi\) введём \(t_A(\sigma), \sigma = e(I)\) - \textbf{время до остановки} алгоритма \(A\) на входе \(I\) (в числе шагов ДМТ).
\item \(\forall m \in \mathbb{N}: T_A(m) = \max_{\sigma \in \Sigma^*, |\sigma| \leq m}t_A(\sigma)\)
\end{enumerate}

Класс \(\mathbb{P}\) - класс \textbf{полиномиально разрешимых} задач:
\begin{equation*}
\mathbb{P} = \{\alpha(\Pi, e) | \exists A \text{ -- алгоритм, решающий } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: T_A(\cdot) \leq p(.)\}
\end{equation*}
\textbf{Замечание}: это определение относится только к задачам распознавания свойств.
\subsection{Задача 2}
\label{sec:org2309948}
Предложить алгоритм распознавания простоты числа, найти его функцию временной сложности и
оценить её.
\subsection{Самая интересная часть}
\label{sec:orgbd984e8}
Алгоритмически неразрешимая задача(Матиясевич): по коэффициентам многочлена проверить у него
наличие целочисленных корней.

\textbf{НМТ} \(\hat{A} = \{A_s\}_{s \in \Sigma^*}\), где \(A_s\) - ДМТ с алфавитом \(\Sigma\).
\(A(\sigma)\) останавливается тогда, когда останавливается первая из них, принимающая \(\sigma\).
Множество слов, принимаемых НМТ, совпадает с множеством слов, на которых она применима.

\textbf{Функция временной сложности} НМТ \(\hat{A}\) решения \(\Pi\) -- функция \(\hat{T}_{\hat A}(\cdot)\), для которой:
\begin{enumerate}
\item \(\forall I \in \Pi\) вводим \textbf{время до остановки} \(t_{\hat{A}}(\sigma), \sigma = e(I)\) -- время до
\end{enumerate}
остановки первой из ДМТ плюс время прочтения её идентификатора: \(t_{\hat{A}} = t_{A_s}(\sigma) + |s|\).
\begin{enumerate}
\item \(\forall m \in \mathbb{N}: T_{\hat{A}}(m) = \max_{\sigma \in \alpha(\Pi, e): |\sigma| \leq m}\inf_{s: \sigma \in \alpha(A_s)}(t_{A_s}(\sigma) + |s|)\)
\end{enumerate}

Класс \(\mathbb{NP}\) - класс \textbf{недетерминированно полиномиально разрешимых} задач:
\begin{equation*}
\mathbb{NP} = \{\alpha(\Pi, e) | \exists \hat{A} \text{ -- НМТ, решающая } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: \hat{T}_{\hat{A}}(\cdot) \leq p(.)\}
\end{equation*}
\textbf{Замечание}: как и предыдущее определение, это определение применимо только к задачам
распознавания свойств.
\begin{Statement}
\begin{equation*}
\mathbb{P} \subseteq \mathbb{NP}
\end{equation*}
\end{Statement}
Пусть \(\Pi\) - массовая задача распознавания свойств. Задача \(\overline{\Pi}\) называется
\textbf{дополнительной} задачей к \(\Pi\), если \(Y(\overline{\Pi}) = D(\Pi) \backslash Y(\Pi)\).
Класс co-\(\mathbb{P} = \{\overline{\Pi} | \Pi \in \mathbb{P}\}\).
Класс co-\(\mathbb{NP} = \{\overline{\Pi} | \Pi \in \mathbb{NP}\}\).
\begin{Statement}
\begin{equation*}
\text{co-}\mathbb{P} = \mathbb{P}
\end{equation*}
\end{Statement}
Задача \(\Pi\) имеет \textbf{хорошую характеризацию}, если \(\Pi \in \mathbb{NP} \cap \textit{co-}\mathbb{NP}\)
(в частности, \(\mathbb{P} \subseteq \mathbb{NP} \cap \textit{co-}\mathbb{NP}\)).

Рассмотрим все задачи \(\Pi \in \mathbb{NP}\) и введём на нём иерархию задач.
Будем говорить, что \(\Pi_1 \propto \Pi_2\)(\(\Pi_1\) \textbf{полиномиально сводится} к \(\Pi_2\)), если
\(\exists f: \forall I_1 \in \Pi_1, e_1(I_1)\overset{f}{\rightarrow}e_2(I_2): I_1 \in Y(\Pi_1) \Leftrightarrow f(e_1(I_1)) \in Y(\Pi_2), \exists \text{ ДМТ, реализующая } f: \exists p(\cdot): T_{A_f} \leq p(\cdot)\).
В этом случае задача \(\Pi_1\) не сложнее задачи \(\Pi_2\).
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{P}$, то $\Pi_1 \in \mathbb{P}$.
\end{Statement}
\begin{proof}
Если $\Pi_2 \in \mathbb{P}$, то $\exists p_2(\cdot): T_{A_2} \leq p_2(\cdot)$. Тогда для
алгоритма $A_1 = A_2 \circ f \exists p_1(\cdot) = p_2(p_f(\cdot)): T_{A_1} \leq p_1(\cdot)$.
\end{proof}
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{NP}$, то $\Pi_1 \in \mathbb{NP}$.
\end{Statement}
\begin{proof}
Доказательство аналогично предыдущему утверждению.
\end{proof}
Класс \textbf{NP-полных задач}: \(\mathbb{NPC} = \{\Pi \in \mathbb{P} \forall \Pi' \in \mathbb{NP}: \Pi' \propto \Pi\}\).

\textbf{Задача выполнимости}: проверить существование набора \(z\) на котором некоторая формула,
представленная в КНФ, обращается в 1.
\begin{Theorem}[Теорема Кука]
$\mathbb{NPC} \neq \emptyset$: задача выполнимости NP-полна.
\end{Theorem}
\begin{proof}
Покажем, что эта задача принадлежит классу $\mathbb{NP}$. Проверка решения -- подстановка
набора в формулу -- полиномиальна. Формулировку любой задачи класса из $\mathbb{NP}$ можно
записать в виде булева предиката, что и будет сведением этой задачи к задаче SAT.
\end{proof}
\begin{Statement}
\begin{equation*}
\Pi_1 \propto \Pi_2, \Pi_2 \propto \Pi_3 \Rightarrow \Pi_1 \propto \Pi_3
\end{equation*}
\end{Statement}
\begin{proof}
Утверждение следует из того, что суперпозиция полиномов - полином.
\end{proof}
\begin{Statement}
\begin{enumerate}
\item Если $\exists \Pi \in \mathbb{NPC}: \Pi \in \mathbb{P}$, то $\mathbb{P} = \mathbb{NP}$.
\item Если для некоторой $\Pi \in \mathbb{NPC}: \Pi \notin \mathbb{P}$, то $\mathbb{NPC} \subseteq \mathbb{NP} \backslash \mathbb{P}$.
\end{enumerate}
\end{Statement}
\begin{Statement}
Если для некоторой NP-полной задачи $\overline{P} \in \mathbb{NPC}$,
то $\mathbb{NPC} = \text{co-}\mathbb{NPC}$.
\end{Statement}
\begin{proof}
Пусть $\Pi' \in \mathbb{NP}: \overline{\Pi'} \propto \overline{P}, \overline{\Pi} \in \mathbb{NP}$,
поэтому $\overline{\Pi'}$ поэтому $\textit{co-}NPC \subseteq \mathbb{NPC}, \mathbb{NPC} \subseteq \textit{co-}\mathbb{NPC}$.
\end{proof}
Для задачи co-SAT нельзя ли в качестве подсказки дать дизъюнкцию, всегда обращающуся в ноль?
\begin{Statement}
Если $\Pi' \in \mathbb{NP}$ и $\exists \Pi \in \mathbb{NPC}: \Pi \propto \Pi'$, то
$\Pi' \in \mathbb{NPC}$.
\end{Statement}
\begin{proof}
Это следует из транзитивности полиномиальной сводимости.
\end{proof}
Задача \textbf{булево линейное неравенство}:\\
Пусть $A \in \mathbb{R}^{n\times n}, b \in \mathbb{R}^{1\times n}$. Существует ли
$z \in \mathbb{B}^n:$
\begin{equation}
Az \preceq b?
\end{equation}
\begin{Statement}
Задача "булево линейное неравенство" NP-полна.
\end{Statement}
\begin{proof}
Эта задача принадлежит классу $\mathbb{NP}$, так как проверка решения выполняется за линейное
время.

Задача SAT сводится к задаче на линейное неравенство, откуда следует NP-полнота этой задачи.
\end{proof}
Задачи SMT и "целочисленное линейное неравенство" - обобщения задач SAT и
"булево линейное неравенство" соответственно, также являются NP-полными. Доказательство
принадлежности задачи линейного программирования классу $\mathbb{NP}$ является нетривиальным.
\subsection{Задача 3}
\label{sec:org3ae75c8}
Доказать, что задача проверки простоты числа принадлежит классу \(\textit{co-}\mathbb{NP}\).

\textbf{Задача 3-выполнимости}: задача КНФ дизъюнкций с ровно тремя слагаемыми. Эта задача
полиномиально сводится к задаче SAT, и поэтому принадлежит к классу \(\mathbb{NP}\).
\subsection{Задача 4}
\label{sec:org00d79e5}
Разложить конъюкцию одной или двух переменных в произведение конъюкции трёх переменных.
\begin{Statement}
Задача 3-выполнимости NP-полна.
\end{Statement}
\begin{proof}
Сведём задачу выполнимости к задаче 3-выполнимости. Разложим все длинные конъюкции в
произведение концъюкций длины 3: если выполнена конъюкция
\begin{equation*}
y_1 \vee y_2 \vee \ldots \vee y_k,
\end{equation*}
то выполнено произведение:
\begin{equation*}
(y_1 \vee y_2 \vee u_1)(y_3 \vee \overline{u_1} \vee u_2)\ldots(y_{k - 1} \vee y_k \vee \overline{u_{k - 3}})
\end{equation*}
для некоторых $u_1, u_2, \ldots, u_{k - 3}$. При этом количество переменных увеличилось не более,
чем в два раза.
\end{proof}
\begin{Theorem}
$\forall \Pi \in \mathbb{NP} \exists \text{ ДМТ } A \text{, решающая } \Pi, \exists p(\cdot)
T_A(\cdot) \leq 2^{p(\cdot)}$
\end{Theorem}
\begin{proof}
Так как $\Pi \in \mathbb{NP}$, то $\exists \text{ НМТ } \hat{A}: \forall I \in Y(\Pi) \exists$
$s: |s| \leq p_1(|I|), z_{A_s} \leq p_2(|I|)$. Будем моделировать НМТ с помощью ДМТ,
каждому состоянию оригинальной НМТ отвечает множество состояний ДМТ. При переходе между
состояниями делаем переходы на каждой ДМТ, "входящей" в НМТ. Тогда
\begin{equation*}
t_A(\sigma) \leq p_2(|\sigma|)|\Sigma|^{p_1(\sigma)}
\end{equation*}
\end{proof}
Класс \textbf{NP-трудных} задач(\(\mathbb{NP}-hard\)) -- это:
\begin{enumerate}
\item задачи оптимизации, для которых соответствующая задача распознавания свойств NP-полна.
\item задачи распознавания свойств, для которых есть NP-полная задача, сводимая к ней, но принадлежность которой к классу \(\mathbb{NP}\) не доказана.
\item все задачи, к которым сводятся(по Тьюрингу) NP-трудные задачи(\(\Pi' \propto_T \Pi\)).
\end{enumerate}
Задача \(\Pi\) принадлежит классу \(PSPACE\), если её можно решить за полиномиальное количество
памяти на ДМТ. Все ранее рассмотренные классы входят в класс \(PSPACE\). Вопрос строгого
включения класса \(P\) в класс \(PSPACE\) остаётся открытым.
\subsection{Задача о рюкзаке}
\label{sec:org9614ebc}
Найти
\begin{equation}
max_{z \in B^n}\sum_{i = 1}^nc_iz_i,
\end{equation}
при том, что
\begin{equation}
\sum_{i = 1}^nw_iz_i \leq K
\end{equation}
Условия: $K, c_i, W_i, B \in \mathbb{N}$.
Эта задача сводится к задаче булева линейного программирования и является NP-полной.

Задача решается методом динамического программирования. Сложность решения $nKO(\log(c_i, w_i, K))$.
Если $K \sim p(n)$, то задача, тем не менее, решается полиномиально.

Введём \(num(I)\) -- максимальное по модулю целое число, фигурирующее в записи задачи \(I\). ДМТ
\(A\) решения задачи \(\Pi\) называется \textbf{псевдополиномиальным}, если
\(\exists p(\cdot, \cdot): \forall I \in \Pi T_A(I) \leq p(|I|, num(I))\).
\textbf{Полиномиальным сужением} задачи \(\Pi\) называется задача \(\Pi_{p(\cdot)} = \{I \in \Pi | num(I) \leq p(|I|)\}\).

Задача \(\Pi\) распознавания свойств называется \textbf{сильно-NP-полной, если} её полиномиальное сужение
NP-полно.
\begin{Theorem}
Если $\mathbb{P} \neq \mathbb{NP}$, то ни для какой сильно-NP-полной задачи нет псевдополиномиального
алгоритма её решения.
\end{Theorem}
\begin{proof}
Пусть для некоторой сильно-NP-полной задачи мы нашли псевдополиномиальное решение. Тогда
$\exists p(\cdot, \cdot): \exists A: t_A(I)O \leq p(|I|, num(I))$, соответственно,
$\forall I \in \Pi_{p(\cdot)}: T_A(I) \leq p(|I|, p(|I))$, поэтому $\Pi_{p(\cdot)} \in \mathbb{P}$,
откуда следует, что $\mathbb{P} = \mathbb{NP}$. Противоречие.
\end{proof}
\textbf{Задача оптимизации} -- найти значение и реализацию
\begin{equation}
Opt(I) = \max_{z \in S_I}f_I(z)
\end{equation}
\section{Задача оптимизации}
\label{sec:org4435611}
\zall
\(f_I(z)\) называется \textbf{целевой функцией}, значение функции называется \textbf{значением оптимума}, а
точка, в которой она достигается -- \textbf{реализацией оптимума}.
\(S_i \subset \mathbb{Z}^{n_I}\) -- \textbf{допустимая область}, \(f_I: S_I \rightarrow \mathbb{Z}\).

Алгоритм \(A\) называется \textbf{приближённым алгоритмом} решения задачи \(\Pi\) оптимизации, если
\(\forall I \in \Pi A(I) \text{ даёт } z^A(I) \in S_I\). Значение целевой функции в точке \(z^A(I)\)
называется \textbf{приближённым значением} и обозначается \(A_f(I)\).
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall C \not\exists$ приближённого алгоритма $A$,
решающего задачу о рюкзаке с $T_a(\cdot) \leq p(\cdot)$ и $|A_f(I) - Opt(I)| < C$.
\end{Statement}
\begin{proof}
Пусть такой алгоритм существует. Построим по нему точный полиномиальный алгоритм решения
задачи о рюкзаке: от задачи $I$ перейдём к задаче $I'$ с полезностями $c'_i = c_i(C + 1)$.
Применив алгоритм $A$ на $I'$ и разделив ответ на $C + 1$, получим $A'_f(I)$. Тогда
$Opt(I') = (C + 1)Opt(I) \Rightarrow |Opt(I) - A'(I)| = |\frac{Opt(I') - A_f(I')}{C + 1}| \leq \frac{C}{C + 1}$
$\Rightarrow |Opt(I) - A'(I)| = 0 \Rightarrow A'$ -- точный алгоритм, являющийся при этом
полиномиальным, что входит в противоречие с $\mathbb{P} \neq \mathbb{NP}$.
\end{proof}
Приближённый алгоритм \(A\) решения задачи оптимизации \(\Pi\) называется \(\varepsilon\)-приближённым,
если \(\forall I \in \Pi: \Delta_A(I) = |\frac{Opt(I) - A_f(I)}{Opt(I)}| < \varepsilon\).
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall \varepsilon > 0 \not\exists \varepsilon$-приближённого
полиномиального решения общей задачи коммивояжёра.
\end{Statement}
Если параметры задачи целые, то длина входа ограничена снизу числом $n$.
\textbf{Размерность} задачи - размер массива входных данных.

\textbf{Полностью полиномиальной приближённой схемой} решения задачи оптимизации $\Pi$ называется
$\{A_{\varepsilon}\}$, где $\forall \varepsilon > 0 \forall I A_{\varepsilon}$ приближённо решает
$I$ с $t_{A_{\varepsilon}}(I) \leq p(|I|, \frac1{\varepsilon})$ и $\Delta_A(I) \leq \varepsilon$.
Тогда $T_{A_{\varepsilon}}(w) \leq p(w, \frac1{\varepsilon})$.

\begin{Statement}
Если для задачи оптимизации выполнены условия:
\begin{enumerate}
\item Существует псевдополиномиальный алгоритм решения
\item $\forall I \in \Pi: |Opt(I)| \leq p_1(|I|, num(I))$ и $|num(I)| \leq p_2(|I|, Opt(I))$.
\item $\sigma$ разбивается на $\sigma_f$, кодирующую $f_I$, и $\sigma_S$, кодирующую $S_I$ и $\forall z \in S_I f_I(z)$ линейна по $\sigma_f$.
\end{enumerate}
то существует полностью полиномиальная приближённая схема решения задачи $\Pi$.
\end{Statement}
\begin{Statement}
Если для задачи оптимизации соответствующая ей задача распознавания свойств является сильно
$NP$-полной и $\exists p'(\cdot): |Opt(I)| \leq p'(num(I)) \forall I \in \Pi$, то если
$\mathbb{P} \neq \mathbb{NP} \not\exists$ полностью полиномиальной приближённой схемы решения
$\Pi$.
\end{Statement}
\begin{proof}
Пусть $\exists$ искомая схема $\{A_{\varepsilon}\}$. Тогда построим алгоритм $A': \forall I \in \Pi A'$
вызывает $A_{\varepsilon}$, где $\varepsilon = \frac1{p'(num(I)) + 1}$. Тогда
$|Opt(I) - A'_f(I)| \leq \varepsilon Opt(I) \leq \frac{Opt(I)}{p'(num(I)) + 1} \leq \frac{p'(num(I))}{p'(num(I)) + 1} < 1$
$\Rightarrow |Opt(I) - A'(I)| = 0$, т. е. $A'$ - точный алгоритм, являющийся псевдополиномиальный.
\end{proof}
\section{Линейное программирование}
\label{sec:org8f126fe}
\subsection{Литература}
\label{sec:orga32e7e5}
\begin{enumerate}
\item Л. Г. Хачиян "Сложность задач ЛП".
\end{enumerate}

Задача \textbf{линейного программирования} -- решить систему неравенств:
\zall
\begin{equation}
\begin{cases}
a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n \leq b_1, \\
a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n \leq b_2, \\
\ldots, \\
a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n \leq b_m,
\end{cases}
(Ax \leq B), a_{ij}, b_i \in \mathbb{Z}
\end{equation}
При условии, что нулевых строк нет.

С этой задачей связана задача \textbf{линейное неравенство} -- существует ли решение (1)?
Этой задаче соответствует \textbf{основная задача линейного программирования}: найти
\begin{equation}
\max_{Ax \leq b}(c, x) = \max_{Ax \leq B}\sum_{i = 1}^mc_ix_i
\end{equation}
В этой задаче $x \in \mathbb{R}^n$, а найти нужно (2).
Оказывается, что задачи ЛН и ЛП полиномиальны.

\textbf{Каноническая форма} задачи ЛП:
\begin{equation}
\max_{Ax = b, x \geq 0}(c, x)
\end{equation}
Ещё одна форма:
\begin{equation}
\max_{Ax \leq b, x \geq 0}(c, x)
\end{equation}
\subsection{Задача 5}
\label{sec:org1bc8b5a}
Свести (4) к (2).

Ограничения описывают некоторый многогранник(а точнее, полиэдр, поскольку эта фигура не
обязательно ограничена) в n-мерном пространстве. С точки зрения геометрии, нужно найти
наиболее удалённую от нуля гиперплоскость уровня, пересекающую полиэдр.

\begin{Statement}[Принцип граничных решений]
Если задача (2) имеет решения, то $\exists$ подматрица $A_M$ матрицы $A$ такая, что любое
решение $x^*: A_Mx^* = B_M$ является решением задачи (2), $|M| = n$.
\end{Statement}
На этом наблюдении основан метод \textbf{направленного перебора} или \textbf{симплекс-метод} (Фурье).
Решаем систему, находим угловые точки, от угловой точки переходим к точке максимального роста.
Вообще говоря, количество вершин экспоненциально, поэтому полиномиальную версию симплекс-метода
получить не удаётся.
\end{document}
