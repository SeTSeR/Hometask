#+LATEX_HEADER:\usepackage{amsmath}
#+LATEX_HEADER:\usepackage{esint}
#+LATEX_HEADER:\usepackage[english,russian]{babel}
#+LATEX_HEADER:\usepackage{mathtools}
#+LATEX_HEADER:\usepackage{amsthm}
#+OPTIONS: toc:nil
#+LATEX_HEADER:\usepackage[top=0.8in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}

#+LATEX_HEADER:\def\zall{\setcounter{lem}{0}\setcounter{cnsqnc}{0}\setcounter{th}{0}\setcounter{Cmt}{0}\setcounter{equation}{0}\setcounter{stnmt}{0}}

#+LATEX_HEADER:\newcounter{lem}\setcounter{lem}{0}
#+LATEX_HEADER:\def\lm{\par\smallskip\refstepcounter{lem}\textbf{\arabic{lem}}}
#+LATEX_HEADER:\newtheorem*{Lemma}{Лемма \lm}

#+LATEX_HEADER:\newcounter{th}\setcounter{th}{0}
#+LATEX_HEADER:\def\th{\par\smallskip\refstepcounter{th}\textbf{\arabic{th}}}
#+LATEX_HEADER:\newtheorem*{Theorem}{Теорема \th}

#+LATEX_HEADER:\newcounter{cnsqnc}\setcounter{cnsqnc}{0}
#+LATEX_HEADER:\def\cnsqnc{\par\smallskip\refstepcounter{cnsqnc}\textbf{\arabic{cnsqnc}}}
#+LATEX_HEADER:\newtheorem*{Consequence}{Следствие \cnsqnc}

#+LATEX_HEADER:\newcounter{Cmt}\setcounter{Cmt}{0}
#+LATEX_HEADER:\def\cmt{\par\smallskip\refstepcounter{Cmt}\textbf{\arabic{Cmt}}}
#+LATEX_HEADER:\newtheorem*{Note}{Замечание \cmt}

#+LATEX_HEADER:\newcounter{stnmt}\setcounter{stnmt}{0}
#+LATEX_HEADER:\def\st{\par\smallskip\refstepcounter{stnmt}\textbf{\arabic{stnmt}}}
#+LATEX_HEADER:\newtheorem*{Statement}{Утверждение \st}

* Структура курса
+ Введение в теорию сложности
+ Линейное программирование
+ Методы непрерывной оптимизации
+ Методы решения переборных задач
* Литература
1. Новикова Н. М. "Дискретные и непрерывные задачи оптимизации"
2. М. Гэри, Д. Джонсон "Вычислительные машины и труднорешаемые задачи"
3. Х. Пападимитриу, К. Стайглиц "Комбинаторные оптимизации"
4. http://www.ccas.ru/depart/malashen/53kmsu.htm
* Введение в теорию сложности
#+begin_export latex
\textbf{Массовая задача} $\Pi = \{I\}$, где $I$ - \textbf{индивидуальная задача}. Массовая задача определяется:
\begin{enumerate}
\item списком параметров
\item требованиями к решению
\end{enumerate}
#+end_export
** Задача коммивояжёра
Задан взвешенный ориентированный граф: вершины и матрицы. Нужно найти маршрут через все
вершины графа минимального веса.
#+begin_export latex
\begin{equation*}
\text{Найти } \pi^0\{1, \ldots, n\} \rightarrow \pi(1), \ldots, \pi(n), \\
\pi^0 \in \operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1}))\right\}
\end{equation*}
#+end_export
Всего порядка $n!$ маршрутов.

Задача *бездомного* коммивояжёра - нужно найти гамильтонов путь в графе. Эта задача имеет ту
же сложность.

Задача построения *остовного дерева* минимального веса.

С точки зрения сложности задачи делятся на два класса: полиномиальная или экспоненциальная
зависимость затрат на решения от длины входа.
** Задачи распознавания свойств
Задачи, в которых требования к решению выражаются предикатом. В этих терминах задача коммивояжёра
формулируется так:
#+begin_export latex
\begin{equation*}
\{n, \{d_{ij} = d(c_i, c_j)\}, B\}
\end{equation*}
\begin{equation*}
\exists? \pi: \left\{\operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1})\right\}\right\} \leq B
\end{equation*}
#+end_export
С помощью бинарного поиска задача распознавания свойств сводится к оптимизационной задаче,
класс задачи при этом не меняется.
*Кодировка* массовой задачи $\Pi$ включает в себя:
1. Алфавит $\Sigma$ - конечное множество символов.
2. $\Sigma^*$ - множество слов в алфавите $\Sigma$. Длину слова $\sigma$ будем обозначать $|\sigma|$.
3. *Функция кодирования* $e: \{I\} \Rightarrow \Sigma^*, e(I) = \sigma$, обладающая свойствами:
   + Инъективность(однозначность): $\forall I_1 \neq I_2 e(I_1) \neq e(I_2)$.
   + Полиноминальность кодирования и декодирования: $\exists p(\cdot)\text{( --- полином )} \forall I \in \Pi: |e(I)| \leq p(|I|), |e^{-1}(\sigma)| \leq p(|\sigma|)$
   + Неизбыточность: $\forall e'$, обладающей предыдущими двумя свойствами $\exists p(\cdot): |e(I)| \leq p(|e'(I)|)$ на наборе задач, для которого $\forall m \exists I |e(I)| \leq m$.
** Задача 1
Задача построения остовного дерева минимального веса(+задача распознавания свойства):
#+begin_export latex
\begin{equation*}
n, d_{ij} \in \mathbb{N}_0
\end{equation*}
#+end_export
Предложить неизбыточную кодировку входа, найти длину входа и сравнить её с оценкой для задачи
коммивояжёра:
#+begin_export latex
\begin{equation*}
n + \lceil\log_2B\rceil + \max_{ij}\lceil\log_2d_{ij}\rceil
\end{equation*}
#+end_export
** Язык задачи
Помимо кодировки с задачей связывается *язык*: $\alpha(\Pi, e) = \{\sigma \in \Sigma^* | \sigma = e(I), I \in Y(\Pi)\}$,
где $Y(\Pi)$ -- это множество индивидуальных задач, на которых ответ является истиной.

Алгоритм - программа для ДМТ, по кодировке задачи выдающая ответ. Алгоритм $A$ *применим* к $\sigma \in \Sigma^*$,
если на этом слове он останавливается. Алгоритм $A$ *принимает* слово $\sigma$, если он
останавливается на нём и выдаёт истинный ответ.
#+begin_export latex
\begin{equation*}
\alpha(A) = \{\sigma \in \Sigma^* | \Sigma \text{-- алфавит } A, A(\sigma) = true\}
\end{equation*}
#+end_export
Алгоритм A *решает* задачу $\Pi$ с кодировкой $e$, если $\forall \sigma \in \Sigma^* A$
останавливается и $\alpha(A) = \alpha(\Pi, e)$.

*Функция временной сложности* алгоритма $A$ решения $\Pi$ называется функция $T_A(\cdot)$, обладающая
свойствами:
1. $\forall I \in \Pi$ введём $t_A(\sigma), \sigma = e(I)$ - *время до остановки* алгоритма $A$ на входе $I$ (в числе шагов ДМТ).
2. $\forall m \in \mathbb{N}: T_A(m) = \max_{\sigma \in \Sigma^*, |\sigma| \leq m}t_A(\sigma)$

Класс $\mathbb{P}$ - класс *полиномиально разрешимых* задач:
#+begin_export latex
\begin{equation*}
\mathbb{P} = \{\alpha(\Pi, e) | \exists A \text{ -- алгоритм, решающий } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: T_A(\cdot) \leq p(.)\}
\end{equation*}
#+end_export
*Замечание*: это определение относится только к задачам распознавания свойств.
** Задача 2
Предложить алгоритм распознавания простоты числа, найти его функцию временной сложности и
оценить её.
** Самая интересная часть
Алгоритмически неразрешимая задача(Матиясевич): по коэффициентам многочлена проверить у него
наличие целочисленных корней.

*НМТ* $\hat{A} = \{A_s\}_{s \in \Sigma^*}$, где $A_s$ - ДМТ с алфавитом $\Sigma$.
$A(\sigma)$ останавливается тогда, когда останавливается первая из них, принимающая $\sigma$.
Множество слов, принимаемых НМТ, совпадает с множеством слов, на которых она применима.

*Функция временной сложности* НМТ $\hat{A}$ решения $\Pi$ -- функция $\hat{T}_{\hat A}(\cdot)$, для которой:
1. $\forall I \in \Pi$ вводим *время до остановки* $t_{\hat{A}}(\sigma), \sigma = e(I)$ -- время до
остановки первой из ДМТ плюс время прочтения её идентификатора: $t_{\hat{A}} = t_{A_s}(\sigma) + |s|$.
2. $\forall m \in \mathbb{N}: T_{\hat{A}}(m) = \max_{\sigma \in \alpha(\Pi, e): |\sigma| \leq m}\inf_{s: \sigma \in \alpha(A_s)}(t_{A_s}(\sigma) + |s|)$

Класс $\mathbb{NP}$ - класс *недетерминированно полиномиально разрешимых* задач:
#+begin_export latex
\begin{equation*}
\mathbb{NP} = \{\alpha(\Pi, e) | \exists \hat{A} \text{ -- НМТ, решающая } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: \hat{T}_{\hat{A}}(\cdot) \leq p(.)\}
\end{equation*}
#+end_export
*Замечание*: как и предыдущее определение, это определение применимо только к задачам
распознавания свойств.
#+begin_export latex
\begin{Statement}
\begin{equation*}
\mathbb{P} \subseteq \mathbb{NP}
\end{equation*}
\end{Statement}
#+end_export
Пусть $\Pi$ - массовая задача распознавания свойств. Задача $\overline{\Pi}$ называется
*дополнительной* задачей к $\Pi$, если $Y(\overline{\Pi}) = D(\Pi) \backslash Y(\Pi)$.
Класс co-$\mathbb{P} = \{\overline{\Pi} | \Pi \in \mathbb{P}\}$.
Класс co-$\mathbb{NP} = \{\overline{\Pi} | \Pi \in \mathbb{NP}\}$.
#+begin_export latex
\begin{Statement}
\begin{equation*}
\text{co-}\mathbb{P} = \mathbb{P}
\end{equation*}
\end{Statement}
#+end_export
Задача $\Pi$ имеет *хорошую характеризацию*, если $\Pi \in \mathbb{NP} \cap \textit{co-}\mathbb{NP}$
(в частности, $\mathbb{P} \subseteq \mathbb{NP} \cap \textit{co-}\mathbb{NP}$).

Рассмотрим все задачи $\Pi \in \mathbb{NP}$ и введём на нём иерархию задач.
Будем говорить, что $\Pi_1 \propto \Pi_2$($\Pi_1$ *полиномиально сводится* к $\Pi_2$), если
$\exists f: \forall I_1 \in \Pi_1, e_1(I_1)\overset{f}{\rightarrow}e_2(I_2): I_1 \in Y(\Pi_1) \Leftrightarrow f(e_1(I_1)) \in Y(\Pi_2), \exists \text{ ДМТ, реализующая } f: \exists p(\cdot): T_{A_f} \leq p(\cdot)$.
В этом случае задача $\Pi_1$ не сложнее задачи $\Pi_2$.
#+begin_export latex
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{P}$, то $\Pi_1 \in \mathbb{P}$.
\end{Statement}
\begin{proof}
Если $\Pi_2 \in \mathbb{P}$, то $\exists p_2(\cdot): T_{A_2} \leq p_2(\cdot)$. Тогда для
алгоритма $A_1 = A_2 \circ f \exists p_1(\cdot) = p_2(p_f(\cdot)): T_{A_1} \leq p_1(\cdot)$.
\end{proof}
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{NP}$, то $\Pi_1 \in \mathbb{NP}$.
\end{Statement}
\begin{proof}
Доказательство аналогично предыдущему утверждению.
\end{proof}
#+end_export
Класс *NP-полных задач*: $\mathbb{NPC} = \{\Pi \in \mathbb{P} \forall \Pi' \in \mathbb{NP}: \Pi' \propto \Pi\}$.

*Задача выполнимости*: проверить существование набора $z$ на котором некоторая формула,
представленная в КНФ, обращается в 1.
#+begin_export latex
\begin{Theorem}[Теорема Кука]
$\mathbb{NPC} \neq \emptyset$: задача выполнимости NP-полна.
\end{Theorem}
\begin{proof}
Покажем, что эта задача принадлежит классу $\mathbb{NP}$. Проверка решения -- подстановка
набора в формулу -- полиномиальна. Формулировку любой задачи класса из $\mathbb{NP}$ можно
записать в виде булева предиката, что и будет сведением этой задачи к задаче SAT.
\end{proof}
\begin{Statement}
\begin{equation*}
\Pi_1 \propto \Pi_2, \Pi_2 \propto \Pi_3 \Rightarrow \Pi_1 \propto \Pi_3
\end{equation*}
\end{Statement}
\begin{proof}
Утверждение следует из того, что суперпозиция полиномов - полином.
\end{proof}
\begin{Statement}
\begin{enumerate}
\item Если $\exists \Pi \in \mathbb{NPC}: \Pi \in \mathbb{P}$, то $\mathbb{P} = \mathbb{NP}$.
\item Если для некоторой $\Pi \in \mathbb{NPC}: \Pi \notin \mathbb{P}$, то $\mathbb{NPC} \subseteq \mathbb{NP} \backslash \mathbb{P}$.
\end{enumerate}
\end{Statement}
\begin{Statement}
Если для некоторой NP-полной задачи $\overline{P} \in \mathbb{NPC}$,
то $\mathbb{NPC} = \text{co-}\mathbb{NPC}$.
\end{Statement}
\begin{proof}
Пусть $\Pi' \in \mathbb{NP}: \overline{\Pi'} \propto \overline{P}, \overline{\Pi} \in \mathbb{NP}$,
поэтому $\overline{\Pi'}$ поэтому $\textit{co-}NPC \subseteq \mathbb{NPC}, \mathbb{NPC} \subseteq \textit{co-}\mathbb{NPC}$.
\end{proof}
Для задачи co-SAT нельзя ли в качестве подсказки дать дизъюнкцию, всегда обращающуся в ноль?
\begin{Statement}
Если $\Pi' \in \mathbb{NP}$ и $\exists \Pi \in \mathbb{NPC}: \Pi \propto \Pi'$, то
$\Pi' \in \mathbb{NPC}$.
\end{Statement}
\begin{proof}
Это следует из транзитивности полиномиальной сводимости.
\end{proof}
#+end_export
Задача *булево линейное неравенство*:\\
#+begin_export latex
Пусть $A \in \mathbb{R}^{n\times n}, b \in \mathbb{R}^{1\times n}$. Существует ли
$z \in \mathbb{B}^n:$
\begin{equation}
Az \preceq b?
\end{equation}
\begin{Statement}
Задача "булево линейное неравенство" NP-полна.
\end{Statement}
\begin{proof}
Эта задача принадлежит классу $\mathbb{NP}$, так как проверка решения выполняется за линейное
время.

Задача SAT сводится к задаче на линейное неравенство, откуда следует NP-полнота этой задачи.
\end{proof}
Задачи SMT и "целочисленное линейное неравенство" - обобщения задач SAT и
"булево линейное неравенство" соответственно, также являются NP-полными. Доказательство
принадлежности задачи линейного программирования классу $\mathbb{NP}$ является нетривиальным.
#+end_export
** Задача 3
Доказать, что задача проверки простоты числа принадлежит классу $\textit{co-}\mathbb{NP}$.

*Задача 3-выполнимости*: задача КНФ дизъюнкций с ровно тремя слагаемыми. Эта задача
полиномиально сводится к задаче SAT, и поэтому принадлежит к классу $\mathbb{NP}$.
** Задача 4
Разложить конъюкцию одной или двух переменных в произведение конъюкции трёх переменных.
#+begin_export latex
\begin{Statement}
Задача 3-выполнимости NP-полна.
\end{Statement}
\begin{proof}
Сведём задачу выполнимости к задаче 3-выполнимости. Разложим все длинные конъюкции в
произведение концъюкций длины 3: если выполнена конъюкция
\begin{equation*}
y_1 \vee y_2 \vee \ldots \vee y_k,
\end{equation*}
то выполнено произведение:
\begin{equation*}
(y_1 \vee y_2 \vee u_1)(y_3 \vee \overline{u_1} \vee u_2)\ldots(y_{k - 1} \vee y_k \vee \overline{u_{k - 3}})
\end{equation*}
для некоторых $u_1, u_2, \ldots, u_{k - 3}$. При этом количество переменных увеличилось не более,
чем в два раза.
\end{proof}
\begin{Theorem}
$\forall \Pi \in \mathbb{NP} \exists \text{ ДМТ } A \text{, решающая } \Pi, \exists p(\cdot)
T_A(\cdot) \leq 2^{p(\cdot)}$
\end{Theorem}
\begin{proof}
Так как $\Pi \in \mathbb{NP}$, то $\exists \text{ НМТ } \hat{A}: \forall I \in Y(\Pi) \exists$
$s: |s| \leq p_1(|I|), z_{A_s} \leq p_2(|I|)$. Будем моделировать НМТ с помощью ДМТ,
каждому состоянию оригинальной НМТ отвечает множество состояний ДМТ. При переходе между
состояниями делаем переходы на каждой ДМТ, "входящей" в НМТ. Тогда
\begin{equation*}
t_A(\sigma) \leq p_2(|\sigma|)|\Sigma|^{p_1(\sigma)}
\end{equation*}
\end{proof}
#+end_export
Класс *NP-трудных* задач($\mathbb{NP}-hard$) -- это:
1) задачи оптимизации, для которых соответствующая задача распознавания свойств NP-полна.
2) задачи распознавания свойств, для которых есть NP-полная задача, сводимая к ней, но принадлежность которой к классу $\mathbb{NP}$ не доказана.
3) все задачи, к которым сводятся(по Тьюрингу) NP-трудные задачи($\Pi' \propto_T \Pi$).
Задача $\Pi$ принадлежит классу $PSPACE$, если её можно решить за полиномиальное количество
памяти на ДМТ. Все ранее рассмотренные классы входят в класс $PSPACE$. Вопрос строгого
включения класса $P$ в класс $PSPACE$ остаётся открытым.
** Задача о рюкзаке
Найти
#+begin_export latex
\begin{equation}
max_{z \in B^n}\sum_{i = 1}^nc_iz_i,
\end{equation}
при том, что
\begin{equation}
\sum_{i = 1}^nw_iz_i \leq K
\end{equation}
Условия: $K, c_i, W_i, B \in \mathbb{N}$.
Эта задача сводится к задаче булева линейного программирования и является NP-полной.

Задача решается методом динамического программирования. Сложность решения $nKO(\log(c_i, w_i, K))$.
Если $K \sim p(n)$, то задача, тем не менее, решается полиномиально.
#+end_export

Введём $num(I)$ -- максимальное по модулю целое число, фигурирующее в записи задачи $I$. ДМТ
$A$ решения задачи $\Pi$ называется *псевдополиномиальным*, если
$\exists p(\cdot, \cdot): \forall I \in \Pi T_A(I) \leq p(|I|, num(I))$.
*Полиномиальным сужением* задачи $\Pi$ называется задача $\Pi_{p(\cdot)} = \{I \in \Pi | num(I) \leq p(|I|)\}$.

Задача $\Pi$ распознавания свойств называется *сильно-NP-полной, если* её полиномиальное сужение
NP-полно.
#+begin_export latex
\begin{Theorem}
Если $\mathbb{P} \neq \mathbb{NP}$, то ни для какой сильно-NP-полной задачи нет псевдополиномиального
алгоритма её решения.
\end{Theorem}
\begin{proof}
Пусть для некоторой сильно-NP-полной задачи мы нашли псевдополиномиальное решение. Тогда
$\exists p(\cdot, \cdot): \exists A: t_A(I)O \leq p(|I|, num(I))$, соответственно,
$\forall I \in \Pi_{p(\cdot)}: T_A(I) \leq p(|I|, p(|I))$, поэтому $\Pi_{p(\cdot)} \in \mathbb{P}$,
откуда следует, что $\mathbb{P} = \mathbb{NP}$. Противоречие.
\end{proof}
#+end_export
*Задача оптимизации* -- найти значение и реализацию
#+begin_export latex
\begin{equation}
Opt(I) = \max_{z \in S_I}f_I(z)
\end{equation}
#+end_export
* Задача оптимизации
\zall
$f_I(z)$ называется *целевой функцией*, значение функции называется *значением оптимума*, а
точка, в которой она достигается -- *реализацией оптимума*.
$S_i \subset \mathbb{Z}^{n_I}$ -- *допустимая область*, $f_I: S_I \rightarrow \mathbb{Z}$.

Алгоритм $A$ называется *приближённым алгоритмом* решения задачи $\Pi$ оптимизации, если
$\forall I \in \Pi A(I) \text{ даёт } z^A(I) \in S_I$. Значение целевой функции в точке $z^A(I)$
называется *приближённым значением* и обозначается $A_f(I)$.
#+begin_export latex
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall C \not\exists$ приближённого алгоритма $A$,
решающего задачу о рюкзаке с $T_a(\cdot) \leq p(\cdot)$ и $|A_f(I) - Opt(I)| < C$.
\end{Statement}
\begin{proof}
Пусть такой алгоритм существует. Построим по нему точный полиномиальный алгоритм решения
задачи о рюкзаке: от задачи $I$ перейдём к задаче $I'$ с полезностями $c'_i = c_i(C + 1)$.
Применив алгоритм $A$ на $I'$ и разделив ответ на $C + 1$, получим $A'_f(I)$. Тогда
$Opt(I') = (C + 1)Opt(I) \Rightarrow |Opt(I) - A'(I)| = |\frac{Opt(I') - A_f(I')}{C + 1}| \leq \frac{C}{C + 1}$
$\Rightarrow |Opt(I) - A'(I)| = 0 \Rightarrow A'$ -- точный алгоритм, являющийся при этом
полиномиальным, что входит в противоречие с $\mathbb{P} \neq \mathbb{NP}$.
\end{proof}
#+end_export
Приближённый алгоритм $A$ решения задачи оптимизации $\Pi$ называется \varepsilon-приближённым,
если $\forall I \in \Pi: \Delta_A(I) = |\frac{Opt(I) - A_f(I)}{Opt(I)}| < \varepsilon$.
#+begin_export latex
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall \varepsilon > 0 \not\exists \varepsilon$-приближённого
полиномиального решения общей задачи коммивояжёра.
\end{Statement}
Если параметры задачи целые, то длина входа ограничена снизу числом $n$.
\textbf{Размерность} задачи - размер массива входных данных.

\textbf{Полностью полиномиальной приближённой схемой} решения задачи оптимизации $\Pi$ называется
$\{A_{\varepsilon}\}$, где $\forall \varepsilon > 0 \forall I A_{\varepsilon}$ приближённо решает
$I$ с $t_{A_{\varepsilon}}(I) \leq p(|I|, \frac1{\varepsilon})$ и $\Delta_A(I) \leq \varepsilon$.
Тогда $T_{A_{\varepsilon}}(w) \leq p(w, \frac1{\varepsilon})$.

\begin{Statement}
Если для задачи оптимизации выполнены условия:
\begin{enumerate}
\item Существует псевдополиномиальный алгоритм решения
\item $\forall I \in \Pi: |Opt(I)| \leq p_1(|I|, num(I))$ и $|num(I)| \leq p_2(|I|, Opt(I))$.
\item $\sigma$ разбивается на $\sigma_f$, кодирующую $f_I$, и $\sigma_S$, кодирующую $S_I$ и $\forall z \in S_I f_I(z)$ линейна по $\sigma_f$.
\end{enumerate}
то существует полностью полиномиальная приближённая схема решения задачи $\Pi$.
\end{Statement}
\begin{Statement}
Если для задачи оптимизации соответствующая ей задача распознавания свойств является сильно
$NP$-полной и $\exists p'(\cdot): |Opt(I)| \leq p'(num(I)) \forall I \in \Pi$, то если
$\mathbb{P} \neq \mathbb{NP} \not\exists$ полностью полиномиальной приближённой схемы решения
$\Pi$.
\end{Statement}
\begin{proof}
Пусть $\exists$ искомая схема $\{A_{\varepsilon}\}$. Тогда построим алгоритм $A': \forall I \in \Pi A'$
вызывает $A_{\varepsilon}$, где $\varepsilon = \frac1{p'(num(I)) + 1}$. Тогда
$|Opt(I) - A'_f(I)| \leq \varepsilon Opt(I) \leq \frac{Opt(I)}{p'(num(I)) + 1} \leq \frac{p'(num(I))}{p'(num(I)) + 1} < 1$
$\Rightarrow |Opt(I) - A'(I)| = 0$, т. е. $A'$ - точный алгоритм, являющийся псевдополиномиальный.
\end{proof}
#+end_export
* Линейное программирование
** Литература
1. Л. Г. Хачиян "Сложность задач ЛП".

Задача *линейного программирования* -- решить систему неравенств:
#+begin_export latex
\zall
\begin{equation}
\begin{cases}
a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n \leq b_1, \\
a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n \leq b_2, \\
\ldots, \\
a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n \leq b_m,
\end{cases}
(Ax \leq b), a_{ij}, b_i \in \mathbb{Z}
\end{equation}
При условии, что нулевых строк нет.
#+end_export

С этой задачей связана задача *линейное неравенство* -- существует ли решение (1)?
Этой задаче соответствует *основная задача линейного программирования*: найти
#+begin_export latex
\begin{equation}
\max_{Ax \leq b}(c, x) = \max_{Ax \leq b}\sum_{i = 1}^mc_ix_i
\end{equation}
В этой задаче $x \in \mathbb{R}^n$, а найти нужно (2).
#+end_export
Оказывается, что задачи ЛН и ЛП полиномиальны.

*Каноническая форма* задачи ЛП:
#+begin_export latex
\begin{equation}
\max_{Ax = b, x \geq 0}(c, x)
\end{equation}
#+end_export
Ещё одна форма:
#+begin_export latex
\begin{equation}
\max_{Ax \leq b, x \geq 0}(c, x)
\end{equation}
#+end_export
** Задача 5
Свести (4) к (2).

Ограничения описывают некоторый многогранник(а точнее, полиэдр, поскольку эта фигура не
обязательно ограничена) в n-мерном пространстве. С точки зрения геометрии, нужно найти
наиболее удалённую от нуля гиперплоскость уровня, пересекающую полиэдр.

#+begin_export latex
\begin{Statement}[Принцип граничных решений]
Если задача (2) имеет решения, то $\exists$ подматрица $A_M$ матрицы $A$ такая, что любое
решение $x^*: A_Mx^* = B_M$ является решением задачи (2), $|M| = n$.
\end{Statement}
#+end_export
На этом наблюдении основан метод *направленного перебора* или *симплекс-метод* (Фурье).
Решаем систему, находим угловые точки, от угловой точки переходим к точке максимального роста.
Вообще говоря, количество вершин экспоненциально, поэтому полиномиальную версию симплекс-метода
получить не удаётся.
