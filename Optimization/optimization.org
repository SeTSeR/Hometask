#+LATEX_HEADER:\usepackage{amsmath}
#+LATEX_HEADER:\usepackage{esint}
#+LATEX_HEADER:\usepackage[english,russian]{babel}
#+LATEX_HEADER:\usepackage{mathtools}
#+LATEX_HEADER:\usepackage{amsthm}
#+OPTIONS: toc:nil
#+LANGUAGE: ru
#+LATEX_HEADER:\usepackage[top=0.8in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}

#+LATEX_HEADER:\def\zall{\setcounter{lem}{0}\setcounter{cnsqnc}{0}\setcounter{th}{0}\setcounter{Cmt}{0}\setcounter{equation}{0}\setcounter{stnmt}{0}}

#+LATEX_HEADER:\newcounter{lem}\setcounter{lem}{0}
#+LATEX_HEADER:\def\lm{\par\smallskip\refstepcounter{lem}\textbf{\arabic{lem}}}
#+LATEX_HEADER:\newtheorem*{Lemma}{Лемма \lm}

#+LATEX_HEADER:\newcounter{th}\setcounter{th}{0}
#+LATEX_HEADER:\def\th{\par\smallskip\refstepcounter{th}\textbf{\arabic{th}}}
#+LATEX_HEADER:\newtheorem*{Theorem}{Теорема \th}

#+LATEX_HEADER:\newcounter{cnsqnc}\setcounter{cnsqnc}{0}
#+LATEX_HEADER:\def\cnsqnc{\par\smallskip\refstepcounter{cnsqnc}\textbf{\arabic{cnsqnc}}}
#+LATEX_HEADER:\newtheorem*{Consequence}{Следствие \cnsqnc}

#+LATEX_HEADER:\newcounter{Cmt}\setcounter{Cmt}{0}
#+LATEX_HEADER:\def\cmt{\par\smallskip\refstepcounter{Cmt}\textbf{\arabic{Cmt}}}
#+LATEX_HEADER:\newtheorem*{Note}{Замечание \cmt}

#+LATEX_HEADER:\newcounter{stnmt}\setcounter{stnmt}{0}
#+LATEX_HEADER:\def\st{\par\smallskip\refstepcounter{stnmt}\textbf{\arabic{stnmt}}}
#+LATEX_HEADER:\newtheorem*{Statement}{Утверждение \st}

* Структура курса
+ Введение в теорию сложности
+ Линейное программирование
+ Методы непрерывной оптимизации
+ Методы решения переборных задач
* Литература
1. Новикова Н. М. "Дискретные и непрерывные задачи оптимизации"
2. М. Гэри, Д. Джонсон "Вычислительные машины и труднорешаемые задачи"
3. Х. Пападимитриу, К. Стайглиц "Комбинаторные оптимизации"
4. http://www.ccas.ru/depart/malashen/53kmsu.htm
* Введение в теорию сложности
#+begin_export latex
\textbf{Массовая задача} $\Pi = \{I\}$, где $I$ - \textbf{индивидуальная задача}. Массовая задача определяется:
\begin{enumerate}
\item списком параметров
\item требованиями к решению
\end{enumerate}
#+end_export
** Задача коммивояжёра
Задан взвешенный ориентированный граф: вершины и матрицы. Нужно найти маршрут через все
вершины графа минимального веса.
#+begin_export latex
\begin{equation*}
\text{Найти } \pi^0\{1, \ldots, n\} \rightarrow \pi(1), \ldots, \pi(n), \\
\pi^0 \in \operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1}))\right\}
\end{equation*}
#+end_export
Всего порядка $n!$ маршрутов.

Задача *бездомного* коммивояжёра - нужно найти гамильтонов путь в графе. Эта задача имеет ту
же сложность.

Задача построения *остовного дерева* минимального веса.

С точки зрения сложности задачи делятся на два класса: полиномиальная или экспоненциальная
зависимость затрат на решения от длины входа.
** Задачи распознавания свойств
Задачи, в которых требования к решению выражаются предикатом. В этих терминах задача коммивояжёра
формулируется так:
#+begin_export latex
\begin{equation*}
\{n, \{d_{ij} = d(c_i, c_j)\}, B\}
\end{equation*}
\begin{equation*}
\exists? \pi: \left\{\operatorname{Arg}\min_{\pi}\left\{\sum_{i = 1}^{n - 1}d(C_{\pi_i}, C_{\pi_{i + 1}}) + d(C_{\pi_n}, C_{\pi_1})\right\}\right\} \leq B
\end{equation*}
#+end_export
С помощью бинарного поиска задача распознавания свойств сводится к оптимизационной задаче,
класс задачи при этом не меняется.
*Кодировка* массовой задачи $\Pi$ включает в себя:
1. Алфавит $\Sigma$ - конечное множество символов.
2. $\Sigma^*$ - множество слов в алфавите $\Sigma$. Длину слова $\sigma$ будем обозначать $|\sigma|$.
3. *Функция кодирования* $e: \{I\} \Rightarrow \Sigma^*, e(I) = \sigma$, обладающая свойствами:
   + Инъективность(однозначность): $\forall I_1 \neq I_2 e(I_1) \neq e(I_2)$.
   + Полиноминальность кодирования и декодирования: $\exists p(\cdot)\text{( --- полином )} \forall I \in \Pi: |e(I)| \leq p(|I|), |e^{-1}(\sigma)| \leq p(|\sigma|)$
   + Неизбыточность: $\forall e'$, обладающей предыдущими двумя свойствами $\exists p(\cdot): |e(I)| \leq p(|e'(I)|)$ на наборе задач, для которого $\forall m \exists I |e(I)| \leq m$.
** Задача 1
Задача построения остовного дерева минимального веса(+задача распознавания свойства):
#+begin_export latex
\begin{equation*}
n, d_{ij} \in \mathbb{N}_0
\end{equation*}
#+end_export
Предложить неизбыточную кодировку входа, найти длину входа и сравнить её с оценкой для задачи
коммивояжёра:
#+begin_export latex
\begin{equation*}
n + \lceil\log_2B\rceil + \max_{ij}\lceil\log_2d_{ij}\rceil
\end{equation*}
#+end_export
** Язык задачи
Помимо кодировки с задачей связывается *язык*: $\alpha(\Pi, e) = \{\sigma \in \Sigma^* | \sigma = e(I), I \in Y(\Pi)\}$,
где $Y(\Pi)$ -- это множество индивидуальных задач, на которых ответ является истиной.

Алгоритм - программа для ДМТ, по кодировке задачи выдающая ответ. Алгоритм $A$ *применим* к $\sigma \in \Sigma^*$,
если на этом слове он останавливается. Алгоритм $A$ *принимает* слово $\sigma$, если он
останавливается на нём и выдаёт истинный ответ.
#+begin_export latex
\begin{equation*}
\alpha(A) = \{\sigma \in \Sigma^* | \Sigma \text{-- алфавит } A, A(\sigma) = true\}
\end{equation*}
#+end_export
Алгоритм A *решает* задачу $\Pi$ с кодировкой $e$, если $\forall \sigma \in \Sigma^* A$
останавливается и $\alpha(A) = \alpha(\Pi, e)$.

*Функция временной сложности* алгоритма $A$ решения $\Pi$ называется функция $T_A(\cdot)$, обладающая
свойствами:
1. $\forall I \in \Pi$ введём $t_A(\sigma), \sigma = e(I)$ - *время до остановки* алгоритма $A$ на входе $I$ (в числе шагов ДМТ).
2. $\forall m \in \mathbb{N}: T_A(m) = \max_{\sigma \in \Sigma^*, |\sigma| \leq m}t_A(\sigma)$

Класс $\mathbb{P}$ - класс *полиномиально разрешимых* задач:
#+begin_export latex
\begin{equation*}
\mathbb{P} = \{\alpha(\Pi, e) | \exists A \text{ -- алгоритм, решающий } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: T_A(\cdot) \leq p(.)\}
\end{equation*}
#+end_export
*Замечание*: это определение относится только к задачам распознавания свойств.
** Задача 2
Предложить алгоритм распознавания простоты числа, найти его функцию временной сложности и
оценить её.
** Самая интересная часть
Алгоритмически неразрешимая задача(Матиясевич): по коэффициентам многочлена проверить у него
наличие целочисленных корней.

*НМТ* $\hat{A} = \{A_s\}_{s \in \Sigma^*}$, где $A_s$ - ДМТ с алфавитом $\Sigma$.
$A(\sigma)$ останавливается тогда, когда останавливается первая из них, принимающая $\sigma$.
Множество слов, принимаемых НМТ, совпадает с множеством слов, на которых она применима.

*Функция временной сложности* НМТ $\hat{A}$ решения $\Pi$ -- функция $\hat{T}_{\hat A}(\cdot)$, для которой:
1. $\forall I \in \Pi$ вводим *время до остановки* $t_{\hat{A}}(\sigma), \sigma = e(I)$ -- время до
остановки первой из ДМТ плюс время прочтения её идентификатора: $t_{\hat{A}} = t_{A_s}(\sigma) + |s|$.
2. $\forall m \in \mathbb{N}: T_{\hat{A}}(m) = \max_{\sigma \in \alpha(\Pi, e): |\sigma| \leq m}\inf_{s: \sigma \in \alpha(A_s)}(t_{A_s}(\sigma) + |s|)$

Класс $\mathbb{NP}$ - класс *недетерминированно полиномиально разрешимых* задач:
#+begin_export latex
\begin{equation*}
\mathbb{NP} = \{\alpha(\Pi, e) | \exists \hat{A} \text{ -- НМТ, решающая } \Pi \text{ с кодировкой } e:
\exists p(\cdot) \text{ -- полином}: \hat{T}_{\hat{A}}(\cdot) \leq p(.)\}
\end{equation*}
#+end_export
*Замечание*: как и предыдущее определение, это определение применимо только к задачам
распознавания свойств.
#+begin_export latex
\begin{Statement}
\begin{equation*}
\mathbb{P} \subseteq \mathbb{NP}
\end{equation*}
\end{Statement}
#+end_export
Пусть $\Pi$ - массовая задача распознавания свойств. Задача $\overline{\Pi}$ называется
*дополнительной* задачей к $\Pi$, если $Y(\overline{\Pi}) = D(\Pi) \backslash Y(\Pi)$.
Класс co-$\mathbb{P} = \{\overline{\Pi} | \Pi \in \mathbb{P}\}$.
Класс co-$\mathbb{NP} = \{\overline{\Pi} | \Pi \in \mathbb{NP}\}$.
#+begin_export latex
\begin{Statement}
\begin{equation*}
\text{co-}\mathbb{P} = \mathbb{P}
\end{equation*}
\end{Statement}
#+end_export
Задача $\Pi$ имеет *хорошую характеризацию*, если $\Pi \in \mathbb{NP} \cap \textit{co-}\mathbb{NP}$
(в частности, $\mathbb{P} \subseteq \mathbb{NP} \cap \textit{co-}\mathbb{NP}$).

Рассмотрим все задачи $\Pi \in \mathbb{NP}$ и введём на нём иерархию задач.
Будем говорить, что $\Pi_1 \propto \Pi_2$($\Pi_1$ *полиномиально сводится* к $\Pi_2$), если
$\exists f: \forall I_1 \in \Pi_1, e_1(I_1)\overset{f}{\rightarrow}e_2(I_2): I_1 \in Y(\Pi_1) \Leftrightarrow f(e_1(I_1)) \in Y(\Pi_2), \exists \text{ ДМТ, реализующая } f: \exists p(\cdot): T_{A_f} \leq p(\cdot)$.
В этом случае задача $\Pi_1$ не сложнее задачи $\Pi_2$.
#+begin_export latex
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{P}$, то $\Pi_1 \in \mathbb{P}$.
\end{Statement}
\begin{proof}
Если $\Pi_2 \in \mathbb{P}$, то $\exists p_2(\cdot): T_{A_2} \leq p_2(\cdot)$. Тогда для
алгоритма $A_1 = A_2 \circ f \exists p_1(\cdot) = p_2(p_f(\cdot)): T_{A_1} \leq p_1(\cdot)$.
\end{proof}
\begin{Statement}
Если $\Pi_1 \propto \Pi_2$ и $\Pi_2 \in \mathbb{NP}$, то $\Pi_1 \in \mathbb{NP}$.
\end{Statement}
\begin{proof}
Доказательство аналогично предыдущему утверждению.
\end{proof}
#+end_export
Класс *NP-полных задач*: $\mathbb{NPC} = \{\Pi \in \mathbb{P} \forall \Pi' \in \mathbb{NP}: \Pi' \propto \Pi\}$.

*Задача выполнимости*: проверить существование набора $z$ на котором некоторая формула,
представленная в КНФ, обращается в 1.
#+begin_export latex
\begin{Theorem}[Теорема Кука]
$\mathbb{NPC} \neq \emptyset$: задача выполнимости NP-полна.
\end{Theorem}
\begin{proof}
Покажем, что эта задача принадлежит классу $\mathbb{NP}$. Проверка решения -- подстановка
набора в формулу -- полиномиальна. Формулировку любой задачи класса из $\mathbb{NP}$ можно
записать в виде булева предиката, что и будет сведением этой задачи к задаче SAT.
\end{proof}
\begin{Statement}
\begin{equation*}
\Pi_1 \propto \Pi_2, \Pi_2 \propto \Pi_3 \Rightarrow \Pi_1 \propto \Pi_3
\end{equation*}
\end{Statement}
\begin{proof}
Утверждение следует из того, что суперпозиция полиномов - полином.
\end{proof}
\begin{Statement}
\begin{enumerate}
\item Если $\exists \Pi \in \mathbb{NPC}: \Pi \in \mathbb{P}$, то $\mathbb{P} = \mathbb{NP}$.
\item Если для некоторой $\Pi \in \mathbb{NPC}: \Pi \notin \mathbb{P}$, то $\mathbb{NPC} \subseteq \mathbb{NP} \backslash \mathbb{P}$.
\end{enumerate}
\end{Statement}
\begin{Statement}
Если для некоторой NP-полной задачи $\overline{P} \in \mathbb{NPC}$,
то $\mathbb{NPC} = \text{co-}\mathbb{NPC}$.
\end{Statement}
\begin{proof}
Пусть $\Pi' \in \mathbb{NP}: \overline{\Pi'} \propto \overline{P}, \overline{\Pi} \in \mathbb{NP}$,
поэтому $\overline{\Pi'}$ поэтому $\textit{co-}NPC \subseteq \mathbb{NPC}, \mathbb{NPC} \subseteq \textit{co-}\mathbb{NPC}$.
\end{proof}
Для задачи co-SAT нельзя ли в качестве подсказки дать дизъюнкцию, всегда обращающуся в ноль?
\begin{Statement}
Если $\Pi' \in \mathbb{NP}$ и $\exists \Pi \in \mathbb{NPC}: \Pi \propto \Pi'$, то
$\Pi' \in \mathbb{NPC}$.
\end{Statement}
\begin{proof}
Это следует из транзитивности полиномиальной сводимости.
\end{proof}
#+end_export
Задача *булево линейное неравенство*:\\
#+begin_export latex
Пусть $A \in \mathbb{R}^{n\times n}, b \in \mathbb{R}^{1\times n}$. Существует ли
$z \in \mathbb{B}^n:$
\begin{equation}
Az \preceq b?
\end{equation}
\begin{Statement}
Задача "булево линейное неравенство" NP-полна.
\end{Statement}
\begin{proof}
Эта задача принадлежит классу $\mathbb{NP}$, так как проверка решения выполняется за линейное
время.

Задача SAT сводится к задаче на линейное неравенство, откуда следует NP-полнота этой задачи.
\end{proof}
Задачи SMT и "целочисленное линейное неравенство" - обобщения задач SAT и
"булево линейное неравенство" соответственно, также являются NP-полными. Доказательство
принадлежности задачи линейного программирования классу $\mathbb{NP}$ является нетривиальным.
#+end_export
** Задача 3
Доказать, что задача проверки простоты числа принадлежит классу $\textit{co-}\mathbb{NP}$.

*Задача 3-выполнимости*: задача КНФ дизъюнкций с ровно тремя слагаемыми. Эта задача
полиномиально сводится к задаче SAT, и поэтому принадлежит к классу $\mathbb{NP}$.
** Задача 4
Разложить конъюкцию одной или двух переменных в произведение конъюкции трёх переменных.
#+begin_export latex
\begin{Statement}
Задача 3-выполнимости NP-полна.
\end{Statement}
\begin{proof}
Сведём задачу выполнимости к задаче 3-выполнимости. Разложим все длинные конъюкции в
произведение концъюкций длины 3: если выполнена конъюкция
\begin{equation*}
y_1 \vee y_2 \vee \ldots \vee y_k,
\end{equation*}
то выполнено произведение:
\begin{equation*}
(y_1 \vee y_2 \vee u_1)(y_3 \vee \overline{u_1} \vee u_2)\ldots(y_{k - 1} \vee y_k \vee \overline{u_{k - 3}})
\end{equation*}
для некоторых $u_1, u_2, \ldots, u_{k - 3}$. При этом количество переменных увеличилось не более,
чем в два раза.
\end{proof}
\begin{Theorem}
$\forall \Pi \in \mathbb{NP} \exists \text{ ДМТ } A \text{, решающая } \Pi, \exists p(\cdot)
T_A(\cdot) \leq 2^{p(\cdot)}$
\end{Theorem}
\begin{proof}
Так как $\Pi \in \mathbb{NP}$, то $\exists \text{ НМТ } \hat{A}: \forall I \in Y(\Pi) \exists$
$s: |s| \leq p_1(|I|), z_{A_s} \leq p_2(|I|)$. Будем моделировать НМТ с помощью ДМТ,
каждому состоянию оригинальной НМТ отвечает множество состояний ДМТ. При переходе между
состояниями делаем переходы на каждой ДМТ, "входящей" в НМТ. Тогда
\begin{equation*}
t_A(\sigma) \leq p_2(|\sigma|)|\Sigma|^{p_1(\sigma)}
\end{equation*}
\end{proof}
#+end_export
Класс *NP-трудных* задач($\mathbb{NP}-hard$) -- это:
1) задачи оптимизации, для которых соответствующая задача распознавания свойств NP-полна.
2) задачи распознавания свойств, для которых есть NP-полная задача, сводимая к ней, но принадлежность которой к классу $\mathbb{NP}$ не доказана.
3) все задачи, к которым сводятся(по Тьюрингу) NP-трудные задачи($\Pi' \propto_T \Pi$).
Задача $\Pi$ принадлежит классу $PSPACE$, если её можно решить за полиномиальное количество
памяти на ДМТ. Все ранее рассмотренные классы входят в класс $PSPACE$. Вопрос строгого
включения класса $P$ в класс $PSPACE$ остаётся открытым.
** Задача о рюкзаке
Найти
#+begin_export latex
\begin{equation}
max_{z \in B^n}\sum_{i = 1}^nc_iz_i,
\end{equation}
при том, что
\begin{equation}
\sum_{i = 1}^nw_iz_i \leq K
\end{equation}
Условия: $K, c_i, W_i, B \in \mathbb{N}$.
Эта задача сводится к задаче булева линейного программирования и является NP-полной.

Задача решается методом динамического программирования. Сложность решения $nKO(\log(c_i, w_i, K))$.
Если $K \sim p(n)$, то задача, тем не менее, решается полиномиально.
#+end_export

Введём $num(I)$ -- максимальное по модулю целое число, фигурирующее в записи задачи $I$. ДМТ
$A$ решения задачи $\Pi$ называется *псевдополиномиальным*, если
$\exists p(\cdot, \cdot): \forall I \in \Pi T_A(I) \leq p(|I|, num(I))$.
*Полиномиальным сужением* задачи $\Pi$ называется задача $\Pi_{p(\cdot)} = \{I \in \Pi | num(I) \leq p(|I|)\}$.

Задача $\Pi$ распознавания свойств называется *сильно-NP-полной, если* её полиномиальное сужение
NP-полно.
#+begin_export latex
\begin{Theorem}
Если $\mathbb{P} \neq \mathbb{NP}$, то ни для какой сильно-NP-полной задачи нет псевдополиномиального
алгоритма её решения.
\end{Theorem}
\begin{proof}
Пусть для некоторой сильно-NP-полной задачи мы нашли псевдополиномиальное решение. Тогда
$\exists p(\cdot, \cdot): \exists A: t_A(I)O \leq p(|I|, num(I))$, соответственно,
$\forall I \in \Pi_{p(\cdot)}: T_A(I) \leq p(|I|, p(|I))$, поэтому $\Pi_{p(\cdot)} \in \mathbb{P}$,
откуда следует, что $\mathbb{P} = \mathbb{NP}$. Противоречие.
\end{proof}
#+end_export
*Задача оптимизации* -- найти значение и реализацию
#+begin_export latex
\begin{equation}
Opt(I) = \max_{z \in S_I}f_I(z)
\end{equation}
#+end_export
* Задача оптимизации
\zall
$f_I(z)$ называется *целевой функцией*, значение функции называется *значением оптимума*, а
точка, в которой она достигается -- *реализацией оптимума*.
$S_i \subset \mathbb{Z}^{n_I}$ -- *допустимая область*, $f_I: S_I \rightarrow \mathbb{Z}$.

Алгоритм $A$ называется *приближённым алгоритмом* решения задачи $\Pi$ оптимизации, если
$\forall I \in \Pi A(I) \text{ даёт } z^A(I) \in S_I$. Значение целевой функции в точке $z^A(I)$
называется *приближённым значением* и обозначается $A_f(I)$.
#+begin_export latex
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall C \not\exists$ приближённого алгоритма $A$,
решающего задачу о рюкзаке с $T_a(\cdot) \leq p(\cdot)$ и $|A_f(I) - Opt(I)| < C$.
\end{Statement}
\begin{proof}
Пусть такой алгоритм существует. Построим по нему точный полиномиальный алгоритм решения
задачи о рюкзаке: от задачи $I$ перейдём к задаче $I'$ с полезностями $c'_i = c_i(C + 1)$.
Применив алгоритм $A$ на $I'$ и разделив ответ на $C + 1$, получим $A'_f(I)$. Тогда
$Opt(I') = (C + 1)Opt(I) \Rightarrow |Opt(I) - A'(I)| = |\frac{Opt(I') - A_f(I')}{C + 1}| \leq \frac{C}{C + 1}$
$\Rightarrow |Opt(I) - A'(I)| = 0 \Rightarrow A'$ -- точный алгоритм, являющийся при этом
полиномиальным, что входит в противоречие с $\mathbb{P} \neq \mathbb{NP}$.
\end{proof}
#+end_export
Приближённый алгоритм $A$ решения задачи оптимизации $\Pi$ называется \varepsilon-приближённым,
если $\forall I \in \Pi: \Delta_A(I) = |\frac{Opt(I) - A_f(I)}{Opt(I)}| < \varepsilon$.
#+begin_export latex
\begin{Statement}
Если $\mathbb{P} \neq \mathbb{NP}$, то $\forall \varepsilon > 0 \not\exists \varepsilon$-приближённого
полиномиального решения общей задачи коммивояжёра.
\end{Statement}
Если параметры задачи целые, то длина входа ограничена снизу числом $n$.
\textbf{Размерность} задачи - размер массива входных данных.

\textbf{Полностью полиномиальной приближённой схемой} решения задачи оптимизации $\Pi$ называется
$\{A_{\varepsilon}\}$, где $\forall \varepsilon > 0 \forall I A_{\varepsilon}$ приближённо решает
$I$ с $t_{A_{\varepsilon}}(I) \leq p(|I|, \frac1{\varepsilon})$ и $\Delta_A(I) \leq \varepsilon$.
Тогда $T_{A_{\varepsilon}}(w) \leq p(w, \frac1{\varepsilon})$.

\begin{Statement}
Если для задачи оптимизации выполнены условия:
\begin{enumerate}
\item Существует псевдополиномиальный алгоритм решения
\item $\forall I \in \Pi: |Opt(I)| \leq p_1(|I|, num(I))$ и $|num(I)| \leq p_2(|I|, Opt(I))$.
\item $\sigma$ разбивается на $\sigma_f$, кодирующую $f_I$, и $\sigma_S$, кодирующую $S_I$ и $\forall z \in S_I f_I(z)$ линейна по $\sigma_f$.
\end{enumerate}
то существует полностью полиномиальная приближённая схема решения задачи $\Pi$.
\end{Statement}
\begin{Statement}
Если для задачи оптимизации соответствующая ей задача распознавания свойств является сильно
$NP$-полной и $\exists p'(\cdot): |Opt(I)| \leq p'(num(I)) \forall I \in \Pi$, то если
$\mathbb{P} \neq \mathbb{NP} \not\exists$ полностью полиномиальной приближённой схемы решения
$\Pi$.
\end{Statement}
\begin{proof}
Пусть $\exists$ искомая схема $\{A_{\varepsilon}\}$. Тогда построим алгоритм $A': \forall I \in \Pi A'$
вызывает $A_{\varepsilon}$, где $\varepsilon = \frac1{p'(num(I)) + 1}$. Тогда
$|Opt(I) - A'_f(I)| \leq \varepsilon Opt(I) \leq \frac{Opt(I)}{p'(num(I)) + 1} \leq \frac{p'(num(I))}{p'(num(I)) + 1} < 1$
$\Rightarrow |Opt(I) - A'(I)| = 0$, т. е. $A'$ - точный алгоритм, являющийся псевдополиномиальный.
\end{proof}
#+end_export
* Линейное программирование
** Литература
1. Л. Г. Хачиян "Сложность задач ЛП".

Задача *линейного программирования* -- решить систему неравенств:
#+begin_export latex
\zall
\begin{equation}
\begin{cases}
a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n \leq b_1, \\
a_{21}x_1 + a_{22}x_2 + \ldots + a_{2n}x_n \leq b_2, \\
\ldots, \\
a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n \leq b_m,
\end{cases}
(Ax \leq b), a_{ij}, b_i \in \mathbb{Z}
\end{equation}
При условии, что нулевых строк нет.
#+end_export

С этой задачей связана задача *линейное неравенство* -- существует ли решение (1)?
Этой задаче соответствует *основная задача линейного программирования*: найти
#+begin_export latex
\begin{equation}
\max_{Ax \leq b}(c, x) = \max_{Ax \leq b}\sum_{i = 1}^mc_ix_i
\end{equation}
В этой задаче $x \in \mathbb{R}^n$, а найти нужно (2).
#+end_export
Оказывается, что задачи ЛН и ЛП полиномиальны.

*Каноническая форма* задачи ЛП:
#+begin_export latex
\begin{equation}
\max_{Ax = b, x \geq 0}(c, x)
\end{equation}
#+end_export
Ещё одна форма:
#+begin_export latex
\begin{equation}
\max_{Ax \leq b, x \geq 0}(c, x)
\end{equation}
#+end_export
** Задача 5
Свести (4) к (2).

Ограничения описывают некоторый многогранник(а точнее, полиэдр, поскольку эта фигура не
обязательно ограничена) в n-мерном пространстве. С точки зрения геометрии, нужно найти
наиболее удалённую от нуля гиперплоскость уровня, пересекающую полиэдр.

#+begin_export latex
\begin{Statement}[Принцип граничных решений]
Если задача (2) имеет решения, то $\exists$ подматрица $A_M$ матрицы $A$ такая, что любое
решение $x^*: A_Mx^* = B_M$ является решением задачи (2), $|M| = n$.
\end{Statement}
#+end_export
На этом наблюдении основан метод *направленного перебора* или *симплекс-метод* (Фурье).
Решаем систему, находим угловые точки, от угловой точки переходим к точке максимального роста.
Вообще говоря, количество вершин экспоненциально, поэтому полиномиальную версию симплекс-метода
получить не удаётся.
Входная матрица -- *симплекс-матрица*:
#+begin_export latex
\begin{equation}
D =
\begin{pmatrix}
c & \square \\
A & b
\end{pmatrix}
a_{ij}, c_i, b_j \in \mathbb{Z}
\end{equation}
#+end_export
** Задача 5'
Свести задачу $Ax \leq b$ к задаче
#+begin_export latex
\begin{equation}
\begin{cases}
A'y = b', \\
y \geq 0,
\end{cases}
\end{equation}
#+end_export
и обратно.
Рассмотрим задачу:
Существует ли $x \in \mathbb{R}_n$ такое, что высказывание:
#+begin_export latex
\begin{equation}
Q_1\ldots Q_nF(<\overline{a}_1, x> \leq b_1, \ldots, <\overline{a}_m, x> \leq b_m)
\end{equation}
#+end_export
истинно?
Эта задача не лежит в классе $\mathbb{NP}$.

Введём обозначение $[A | b] = (A\, b)$.

Для матрицы $H$ с целыми коэффициентами введём обозначение
#+begin_export latex
\begin{equation}
\Delta H = \max_{H' - \text{квадратная подматрица }H}{|\det H'|}
\end{equation}
\begin{Theorem}[Теорема о границах решений]
Если задача (2) размера $m\times n$ \textbf{с целыми коэффициентами} имеет решения, то
существует рациональное решение $x^*$ в шаре $||x|| \leq \sqrt{n}\Delta|[A|b]|$
и значение $d^* = \frac{t}{s}$ такое, что $|s| \leq \Delta(A)$.
\end{Theorem}
\begin{proof}
$\exists A_M$ -- подматрица $A$, $A_M = \{\overline{a}_i, i \in M\}, M \subseteq \{1, \ldots, m\}$:
$A_Mx^* = b_M, b_M = \{b_i | i \in M\}$. По формуле Крамера
\begin{equation}
\forall j: |x_j^*| = \left|\frac{\det(A_M^j || b_M)}{\det(A_M)}\right| \leq |\det(A_M^j) || b_M| \leq \Delta([A | b])
\end{equation}
Откуда
\begin{equation}
||x|| \leq \sqrt{n}\Delta([A | b])
\end{equation}
Второе условие теоремы следует из того, что $|\det(A_M)| \leq \Delta(A)$.
\end{proof}
#+end_export
** Задача 6
Доказать, что длина входа задачи линейного программирования может быть оценена снизу как:
#+begin_export latex
\begin{equation}
\forall I \in \Pi |I| \geq C\ln(n\Delta(D))
\end{equation}
#+end_export
Точка $x_{\varepsilon}$ называется *\varepsilon-приближённым* решением системы (1), если для
неё выполнено условие
#+begin_export latex
\begin{equation}
Ax^{\varepsilon} \leq b + \overline{1}\varepsilon.
\end{equation}
\begin{Theorem}[теорема о мере несовместности]
Если система $(1)$ имеет $\varepsilon$-приближённое решение с числом
$\varepsilon = \varepsilon_1 = \frac1{(n + 2)\Delta(A)}$, то она имеет и точное решение.
\end{Theorem}
\begin{proof}
Найдём минимальное $\varepsilon$ с которым система имеет $\varepsilon$-приближённое решение.
Тогда $\varepsilon^* = -\max_{Ax - \overline{1}\varepsilon \leq b}-\varepsilon = -\max_{[A|-\overline{1}](x, \varepsilon)^T \leq b}<(0, \ldots, 0, -1),(x, \varepsilon)>$
По теореме о границе решений $\varepsilon^* = \frac{t}s, s \leq \Delta([A | -1]) \leq \Delta(A)(n + 1)$.
Тогда или $\varepsilon^* = 0$, или $\varepsilon^* \geq \frac1{\Delta(A)(n + 1)}$.
\end{proof}
#+end_export
Точка $x^{\varepsilon}$ называется *\varepsilon-приближённым* решением (2), если
$x^{\varepsilon}$ -- \varepsilon-приближённое (1) и $<c, x^{\varepsilon} \geq d^* - \varepsilon.$
#+begin_export latex
\begin{Theorem}
Если (2) имеет $\varepsilon$-приближённое решение с $\varepsilon = \varepsilon_2 = \frac1{2n^2\Delta^3(A)}$,
то $\exists$ точное решение.
\end{Theorem}
Обозначим $\Delta = \Delta(D)$.
\textbf{Метод эллипсоидов}:
\begin{enumerate}
\item На каждой итерации проверяем, принадлежит ли центр текущего эллипсоида $X^*_{\varepsilon}$.
\item Если да, пробуем сдвинуться в сторону $c$?
\item Если нет, рассмотрим любое невыполненное ограничение и переносим его в центр. Описываем эллипсоид вокруг него с новым центром, повторяем для него всё то же.
\item Когда объём эллипсоида окажется достаточно малым, можно остановиться.
\end{enumerate}
\begin{equation}
R = \sqrt{n}\Delta, r = \frac{\varepsilon_2}{\sqrt{n}h}, h = \max{|a_{ij}|, |b_i|}
\end{equation}
\begin{Statement}
\begin{equation}
X^*_{\varepsilon_2} \supseteq S_{r/2}
\end{equation}
\begin{equation}
X_{\varepsilon}^* = \{x^{\varepsilon} | x \varepsilon \leq \varepsilon_2, ||x^2|| \leq R\}
\end{equation}
\end{Statement}
\begin{proof}
Пусть $x^*$ -- решение (2). Тогда:
\begin{equation}
\forall x \in O_r(x^*): ||x - x^*|| \leq r |<\overline{a}_i, x> - <\overline{a}_i, x^*>|
\leq ||a_i||\cdot||x - x^*|| \leq \sqrt{n}hr \leq \varepsilon_2
\end{equation}
Аналогично для $c$ и $d$.
\end{proof}
\begin{equation}
0: E := S_R, E' \text{ содержит } E^-(g) = E \cap \{x | <g, x - \xi> \leq 0\}, \xi \text{ -- центр E.}
\end{equation}
Если $\xi \notin X^*_{\varepsilon_2}$, то
1. $\exists i: <a_j, \xi> > b_i + \varepsilon_2 \Rightarrow g = a_i$.
2. иначе $g = -c$.
\begin{Statement}
\begin{equation*}
E^-(g) \supseteq  X^*_{\varepsilon_2}
\end{equation*}
\end{Statement}
\begin{proof}
\begin{equation}
<a_i, x - \xi> \leq 0 \Rightarrow <a_i, x> \leq <a_i, \xi> \Rightarrow x \in E^-(a_i)
\end{equation}
\begin{equation}
x^{\varepsilon_2}: <a_i, x^{\varepsilon_2}> \leq b_i + \varepsilon_2 < <a_i, \xi>
\end{equation}
Полуэллипсоид $E^-(g) \subset E'$ так, что $\frac{V_{E'}}{V_E} < e^{\frac{-1}{2n + 2}}$.
$E'$ выписывается по $E$ за $O(n^2)$ итераций.
\begin{equation}
E' = \left\{x | \frac{x_1^2 + \ldots + x_{n - 1}^2}{\beta^2} + \frac{(x_n - \frac1{n + 1})^2}{\alpha^2} \leq 1\right\},
\alpha = 1 - \frac1{n + 1}, \beta = 1 + \frac1{n^2 + 1}
\end{equation}
\begin{equation}
\alpha = 1 - \frac1{n + 1} \leq e^{\frac{-1}{n + 1}}, \beta \leq e^{\frac1{n^2 + 1}}
\end{equation}
\begin{equation}
\frac{V_{E'}}{V_E} = \alpha\beta^{n - 1} \leq \exp\left\{\frac{-1}{n + 1} + \frac{n - 1}{2(n^2 - 1)}\right\} = e^{\frac{-1}{2n + 2}}
\end{equation}
\end{proof}
Найдём $k: \left(\frac{r}{2R}\right)^n \leq \frac{V_{X^*_{\varepsilon}}}{V_{E_1}} \leq \frac{V_{E_k}}{V_{E_1}} \leq e^{\frac{-k}{2n + 2}}$.
Тогда для $k$ получаем:
\begin{multline}
k \leq n(2n + 2)\ln\frac{2R}{r} \leq n(2n + 2)\ln\frac{2\sqrt{n}\Delta}{\varepsilon/(h\sqrt{n})} =
n(2n + 2)\ln\frac{2n\Delta h}{\varepsilon} = \\
= n(2n + 2)\ln\frac{4n^3\Delta^4h} \leq 4n^3\Delta^5
= O(n^2\ln(n\Delta)) = O(n^2|I|)
\end{multline}
#+end_export
Прямая и двойственная задача ЛП:
#+begin_export latex
\begin{equation}
\max_{Ax \leq b}(c, x) = \min_{\substack{\lambda A = c \\ \lambda \geq 0}}(\lambda, b)
\end{equation}
Если $b_i$ увеличить на 1, то $d^*$ увеличится на $\lambda_i$.\\
#+end_export

*Следствие теоремы двойственности*:
#+begin_export latex
Если $\lambda_i = 0$, то ограничение $b_i$ является несущественным.

\begin{Statement}
Задача линейного программирования эквивалентна задаче решения линейного неравенства:
\begin{equation}
Ax \leq b, (c, x) = (b, \lambda), \lambda A = c, \lambda \geq 0.
\end{equation}
В свою очередь, эта задача эквивалентна решению системы линейных уравнений в неотрицательных
переменных.
\end{Statement}
\begin{Consequence}
Задача ЛП эквивалентна поиску неотрицательного ненулевого решения однородной системы линейных
алгебраических уравнений.
\end{Consequence}
#+end_export
* Математическое программирование
  #+begin_export latex
  \zall
  #+end_export
** Литература
1. Поляк Б. Т. Введение в оптимизацию.
2. Сухарев А. Г., Тимохов А. В., Федоров В. В. Курс методов оптимизации.
3. Мину М. Математическое программирование.
4. Ю. Нестеров. Введение в выпуклую оптимизацию.

Задача математического программирования:
#+begin_export latex
Найти $\min_{x \in X} f(x), \operatorname{arg}\min_{x \in X}f(x) \in \operatorname{Arg}\min_{x \in X}f(x)$.
Задачи математического программирования делятся на дискретные(в частности, целочисленные
и булевы), непрерывные и бесконечномерные. Задачи условной
и безусловной оптимизации. Локальная и глобальная оптимизация.

Задача математической оптимизации является $NP$-трудной, так как задача ЦЛН есть подзадача задачи
математического программирования.
#+end_export

Функция называется *выпуклой* на $X$, если её надграфик на $X$ является выпуклым множеством.
#+begin_export latex
\begin{Statement}
Любая точка локального минимума выпуклой функции есть точка её глобального минимума.
\end{Statement}
#+end_export
** Методы локального спуска
*** Градиентный метод
     #+begin_export latex
  Вектор $h \in \mathbb{R}^n$ называется \textbf{направлением убывания} функции $f$ в точке $x$, если $f(x + \alpha h) < f(x)$
  для всех достаточно малых $\alpha > 0$.
  \begin{Statement}
  Пусть $f$ дифференцируема в точке $x$. Тогда если $(\operatorname{grad} f(x), h) < 0$, то $h$ -- направление
  убывания функции $f$ в точке $x$, а если $h$ -- направление убывания функции $f$ в точке $x$, то $(\operatorname{grad} f(x), h) \leq 0$.
  \end{Statement}
  Спуск при оптимизации происходит в направлении \textbf{антиградиента}. Метод градиентного спуска:
  \begin{equation}
  x^{t + 1} = x^t - \alpha_t\operatorname{grad} f(x^t), t = 1, 2, \ldots, \forall x^i \in \mathbb{R}
  \end{equation}
  Для этого метода справедлива \textit{линейная оценка сходимости}:
\begin{equation}
||x^{t + 1} - x^*|| \leq q||x^* - x^t||, 0 < q < 1
\end{equation}
     #+end_export
*** Метод Ньютона
Разложим $f(x)$ в ряд Тейлора до второго слагаемого:
#+begin_export latex
\begin{equation}
f(x) - f(x^t) = (\operatorname{grad}f(x^t), x - x^t) + \frac12(f''(x)(x - x^t), x - x^t) + o(||x - x^t||^2),
\end{equation}
где $f''(x)$ -- матрица из вторых производных $f(x)$(\textbf{гессиан}). Метод Ньютона:
\begin{equation}
x^{t + 1} = x^t - (f''(x^t))^{-1}\operatorname{grad} f(x^t), t = 1, 2, \ldots,
\end{equation}
где начальное приближение должно находиться достаточно близко к $x^*$.

В некоторых случаях для метода Ньютона справедлива \textit{квадратичная оценка скорости сходимости}:
\begin{equation}
||x^{t + 1} - x^*|| \leq Q||x^t - x^*||^2 \leq \ldots \leq \frac1Q(Q||x^1 - x^*||)^{2^t},
\end{equation}
если $||x^1 - x^*|| < \frac1Q$.
#+end_export
