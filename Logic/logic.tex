% Created 2020-12-30 Wed 21:17
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{esint}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{minted}
\usepackage[top=0.8in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}
\def\zall{\setcounter{lem}{0}\setcounter{cnsqnc}{0}\setcounter{th}{0}\setcounter{Cmt}{0}\setcounter{equation}{0}\setcounter{stnmt}{0}}
\newcounter{lem}\setcounter{lem}{0}
\def\lm{\par\smallskip\refstepcounter{lem}\textbf{\arabic{lem}}}
\newtheorem*{Lemma}{Лемма \lm}
\newcounter{th}\setcounter{th}{0}
\def\th{\par\smallskip\refstepcounter{th}\textbf{\arabic{th}}}
\newtheorem*{Theorem}{Теорема \th}
\newcounter{cnsqnc}\setcounter{cnsqnc}{0}
\def\cnsqnc{\par\smallskip\refstepcounter{cnsqnc}\textbf{\arabic{cnsqnc}}}
\newtheorem*{Consequence}{Следствие \cnsqnc}
\newcounter{Cmt}\setcounter{Cmt}{0}
\def\cmt{\par\smallskip\refstepcounter{Cmt}\textbf{\arabic{Cmt}}}
\newtheorem*{Note}{Замечание \cmt}
\newcounter{stnmt}\setcounter{stnmt}{0}
\def\st{\par\smallskip\refstepcounter{stnmt}\textbf{\arabic{stnmt}}}
\newtheorem*{Statement}{Утверждение \st}
\author{Sergey Makarov}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Sergey Makarov},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode )}, 
 pdflang={Russian}}
\begin{document}

\tableofcontents


\section{Математическая логика}
\label{sec:org986e0c9}
\textbf{Логика} -- междисциплинарная область наук, занимающаяся:
\begin{enumerate}
\item Законами причинно-следственной связи в окружающем мире
\item Проявлением этих законов в рациональном мышлении человека
\item Отражением этих законов в языках
\end{enumerate}
\textbf{Формальная логика} изучает \textbf{формы}, в которых проявляются законы причинно-следственной связи вне зависимости от их содержания.

Законы формальной логики не позволяют получать новую информацию, они используются для её представления в более удобной форме.

\textbf{Основная задача формальной логики}:
Дана база знаний -- набор утверждений \(\Gamma = \{\phi_1, \phi_2, \ldots, \phi_N\}\) и некоторое утверждение \(\psi\). Задача -- проверить, что \(\psi\) выводится из утверждений \(\Gamma\) путём применения законов формальной логики.

Подзадачи:
\begin{enumerate}
\item Придумать язык описания знаний.
\item Выделить систему законов формальной логики.
\item Проверить корректность законов формальной логики.
\item Проверить полноту системы законов логики.
\item Разработать алгоритм проверки выводимости одних предложений из других по заданным логическим законам.
\item Оптимизировать построенный алгоритм.
\end{enumerate}

Для использования системы доказательств в качестве вычислений нужно:
\begin{enumerate}
\item Разработать язык для представления программ в виде логических утверждений.
\item Сделать полученное доказательство конструктивным.
\item Проверить вычислительную корректность этого способа доказательства.
\item Проверить алгоритмическую полноту этого способа доказательства.
\item Сделать этот способ программирования удобным в использовании.
\end{enumerate}

Для доказательства корректности программ также можно использовать методы матлогики. Для этого нужно:
\begin{enumerate}
\item Создать язык для описания требований корректности программ.
\item Разработать правила логического доказательства корректности программ.
\item Разработать алгоритм применения этих правил для доказательства корректности программ относительно заданных спецификаций.
\end{enumerate}

\section{Язык логики предикатов первого порядка}
\label{sec:org974499a}
\textbf{Предикат} -- термин, обозначающий сказуемое.

\textbf{Логика предикатов} изучает законы причинно-следственной зависимости между утверждениями, представленными в виде отношений. Для этого вводится формальный язык, выражения которого предназначены для описания отношений между произвольными предметами.

Этот язык, как и любой другой, определяется:
\begin{enumerate}
\item Алфавитом.
\item Синтаксисом.
\item Семантикой.
\end{enumerate}

Алфавит:
Базовые символы: переменные(\(Var\)), константы(\(Const\)), функциональные переменные(\(Func\)), предикатные символы(\(Pred\)).
Арность функционального/предикатного символа. Тройка \((Const, Func, Pred)\) называется \textbf{сигнатурой} алфавита.

Предметные переменные обозначают имена предметов. Функциональные переменные обозначают операции над предметами. Предикатные символы обозначают отношения между предметами.

Служебные символы:
Логические связки и кванторы:
\begin{enumerate}
\item Конъюкция
\item Дизъюнкция
\item Отрицание
\item Импликация
\item Квантор всеобщности
\item Квантор существования
\end{enumerate}

Также в алфавит входят разделитель и скобки.

Предметы, вступающие в отношения друг с другом, описываются термами.

\textbf{Терм}:
\begin{enumerate}
\item \(x\), если \(x \in Var\).
\item \(c\), если \(c \in Const\).
\item \(f^{(n)}(t_1, t_2, \ldots, t_n)\), если \(f^{(n)} \in Func\), \(t_1, \ldots, t_n\) -- термы.
\end{enumerate}

\(Term\) -- множество термов заданного алфавита. \(Var_t\) -- множество переменных, входящих в состав терма \(t\). \(t(x_1, x_2, \ldots, x_n)\) -- запись, обозначающая терм \(t\), у которого \(Var_t \subseteq \{x_1, x_2, \ldots, x_n\}\). Если \(Var_t = \emptyset\), то \(t\) -- \textbf{основной терм}.

Для описания отношений между предметами используются \textbf{формулы}:

\textbf{атомарная формула}:
\begin{equation*}
P^{(m)}(t_1, \ldots, t_m),
\end{equation*}
если \(P^{(m)} \in Pred, \{t_1, \ldots, t_m\} \subseteq Term\).

\textbf{составная формула}:
\begin{equation*}
(\phi \land \psi), (\phi \lor \psi), (\phi \to \psi), (\neg \phi),
\end{equation*}
если \(\phi, \psi\) -- формулы.
\begin{equation*}
\forall x \phi, \exists x \phi,
\end{equation*}
если \(x \in Var, \phi\) -- формула. \(Form\) -- множество всех формул заданного алфавита.

Предикаты арности 1 называются \textbf{свойствами}.

Вхождение переменной в области действия квантора, связывающего эту переменную, называется \textbf{связанным}. Вхождение переменной в формулу, не являющееся связанным, называется \textbf{свободным}. Переменная называется \textbf{свободной}, если она имеет свободное вхождение в формулу. \(Var_{\phi}\) -- множество свободных переменных \(\phi\). Это множество определяется следующими правилами:
\begin{align*}
\phi = P^{(m)}(t_1, t_2, \ldots, t_m) &\, Var_{\phi} = \cup_{i = 1}^mVar_{t_i}, \\
\phi = \psi_1 \land \psi_2 &\, Var_{\phi} = Var_{\psi_1} \cup Var_{\psi_2}, \\
\phi = \psi_1 \lor \psi_2 \\
\phi = \psi_1 \to \psi_2 \\
\phi = \neg \psi &\, Var_{\phi} = Var_{\psi}, \\
\phi = (\forall x \psi) &\, Var_{\phi} = Var_{\psi} \backslash \{x\}, \\
\phi = (\exists x \psi)
\end{align*}
\(\phi(x_1, x_2, \ldots, x_n)\) -- запись, обозначающая формулу \(\phi\), для которой
\begin{equation*}
Var_{\phi} \subseteq \{x_1, \ldots, x_n\}.
\end{equation*}
Формула $\phi$, для которой $Var_{\phi} = \emptyset$, называется \textbf{замкнутой формулой} или \textbf{предложением}. $CForm$ -- множество всех замкнутых формул.

Служебные символы приоритизированы.
\textbf{Интерпретация} сигнатуры \((Const, Func, Pred)\) -- это алгебраическая система \(I = (D_I, \overline{Const}, \overline{Func}, \overline{Pred})\):
\begin{enumerate}
\item \(D_I\) -- непустое множество, \textbf{область интерпретации}, \textbf{предметная область} или \textbf{универсум}.
\item \(\overline{Const}: Const \to D_I\) -- \textbf{оценка констант}.
\item \(\overline{Func}: Func^{(n)} \to (D_I^n \to D_I)\) -- \textbf{оценка функциональных символов}.
\item \(\overline{Pred}: Pred^{(m)} \to (D_I^m \to \{true, false\})\) -- \textbf{оценка предикатов}.
\end{enumerate}
Пример:
\begin{gather*}
C(x) - \text{ x -- квадрат} \\
S(x) - \text{ x -- шар} \\
B(x) - \text{ x -- чёрный предмет} \\
W(x) - \text{ x -- белый предмет} \\
U(x, y) - \text{ предмет x лежит над предметом y}
\end{gather*}
Каждый белый куб лежит под каким-то чёрным шаром:
\begin{equation*}
\forall x: W(x) \land C(x) \to \exists y: B(y) \land S(y) \land U(y, x)
\end{equation*}
Какой-то белый куб лежит под всеми чёрными шарами:
\begin{equation*}
\exists x: W(x) \land C(x) \land \forall y: B(y) \land S(y) \to U(y, x)
\end{equation*}

Паша любит всех тех, кто любит то, что любит Паша:
\begin{equation*}
\forall x: L(P, x) \to \forall y: L(y, x) \to L(P, y)
\end{equation*}
\begin{equation*}
\forall x: \exists y: L(P, y) \land L(x, y) \to L(P, x)
\end{equation*}

Существует такая замкнутая формула $\varphi$, которая истинна в любой интерпретации с конечной предметной областью, но не является общезначимой:
\begin{equation*}
\forall x: \lnot R(x, x) \land \forall x\forall y\forall z: (R(x, y) \land R(y, z) \to R(x, z)) \to \exists x: \forall y: \lnot R(x, y)
\end{equation*}

Проверить общезначимость формулы:
\begin{equation*}
\phi = \exists x P(x) \to \forall x P(x)
\end{equation*}
Пусть $\phi$ не общезначима, тогда существует интерпретация $I$, опровергающая $\phi$. В этой модели: (слева записаны выполненные утверждения, справа не выполненные)
\begin{align*}
I \not\models \exists x P(x) \to \forall x P(x) \\
I \models \exists x P(x) &\, I \not\models \forall x P(x) \\
\exists d_1 \in I: P(d) = true &\, \exists d_2 \in I: P(d) = false
\end{align*}
В такой "минимальной" интерпретации формула невыполнима, следовательно, $\not\models \phi$.

Проверить общезначимость формулы:
\begin{equation*}
\phi = \forall x P(x) \to \exists x P(x)
\end{equation*}
Пусть $\phi$ не общезначима, тогда существует интерпретация $I$, опровергающая $\phi$. В этой модели:
\begin{align*}
I \not\models \forall x P(x) \to \exists x P(x) \\
I \models \forall x P(x) &\, I \not\models \exists x P(x) \\
I \models \forall x P(x) \\
I \models \forall x \neg P(x)
\end{align*}
Полученное противоречие показывает, что такую интерпретацию построить невозможно, т. е. формула $\phi$ общезначима.

Семантическая таблица --- пара из множеств "потенциально истинных" и "потенциально ложных" формул. Таблица называется выполнимой, если в некоторой интерпретации при некоторых значениях свободных переменных все "потенциально истинные" формулы выполнены, а "потенциально ложные" --- нет. Общезначимость формулы равносильна выполнимости соответствующей таблицы.
Применить подстановку \(\theta\) к формуле \(\varphi\):
\begin{gather*}
\varphi: \forall x (P(x) \to \neg R(y)) \to R(f(x)) \lor \exists y P(y), \\
\theta: \{ x / g(x, c), y / x, z / f(z) \}
\end{gather*}
После однократной подстановки получим:
\begin{equation*}
\forall x (P(x) \to \neg R(x)) \to R(f(g(x, c))) \lor \exists y P(y)
\end{equation*}

Построить композицию подстановок:
\begin{gather*}
\theta = \{x/f(x, c), y/g(u), z/y\} \\
\eta = \{x/g(y), y/z, u/c\}
\end{gather*}
Для композиции получаем:
\begin{equation*}
\theta\eta = \{x/f(g(y), c), y/g(c), u/c\}
\end{equation*}

Унифицировать систему:
\begin{equation*}
\begin{cases}
f(f(x, c), y) = f(y, f(z, z)) \\
f(u, v) = y
\end{cases}
\end{equation*}
Применяя правила, получим:
\begin{multline*}
\begin{cases}
f(f(x, c), y) = f(y, f(z, z)) \\
f(u, v) = y
\end{cases}
\Rightarrow_3
\begin{cases}
f(f(x, c), y) = f(y, f(z, z)) \\
y = f(u, v)
\end{cases}
\Rightarrow_5 \\
\Rightarrow_5
\begin{cases}
f(f(x, c), f(u, v)) = f(f(u, v), f(z, z)) \\
y = f(u, v)
\end{cases}
\Rightarrow_1
\begin{cases}
f(x, c) = f(u, v) \\
f(u, v) = f(z, z) \\
y = f(u, v)
\end{cases}
\Rightarrow_1
\begin{cases}
x = u \\
c = v \\
z = u \\
z = v \\
y = f(u, v) \\
\end{cases}
\Rightarrow_3 \\
\Rightarrow_3
\begin{cases}
x = u \\
v = c \\
u = z \\
z = v \\
y = f(u, v)
\end{cases}
\Rightarrow_5
\begin{cases}
x = c \\
v = c \\
u = c \\
z = c \\
y = f(c, c)
\end{cases}
\end{multline*}
Получаем решение $\{x/c, v/c, u/c, z/c, y/f(c, c)\}$.

Применить правило резолюции к паре дизъюнктов:
\begin{gather*}
D_1 = P(x, f(y)) \lor \lnot R(g(x, z), f(z)) \\
D_2 = Q(x) \lor R(y, x) \lor \lnot P(g(z, y), z)
\end{gather*}
Рассмотрим дизъюнкты $P(x, f(y))$ и $\lnot P(g(z, y), z)$ и построим для них наименьший общий унификатор. Получим систему:
\begin{equation*}
\begin{cases}
x = g(z, y) \\
f(y) = z
\end{cases}
\Rightarrow \begin{cases}
x = g(f(y), y) \\
z = f(y)
\end{cases}
\end{equation*}
Получили унифицирующую подстановку $\theta = \{x/g(f(y), y), z/f(y)\}$. Применяя правило резолюции, получим резольвенту:
\begin{multline*}
(D_1 \lor D_2)\theta = (\lnot R(g(x, z), f(z)) \lor Q(x) \lor R(y, x))\theta = \\
= \lnot R(g(g(f(y), y), f(y)), f(f(y))) \lor Q(g(f(y), y)) \lor R(y, g(f(y), y))
\end{multline*}

Применить правило склейки к дизъюнкту:
\begin{equation*}
D_1 = P(x) \lor \lnot R(y, z, f(x)) \lor \lnot R(x, f(c), z)
\end{equation*}
Построим НОУ для дизъюнктов $R(y, z, f(x))$ и $R(x, f(c), z)$:
\begin{equation*}
\begin{cases}
y = x \\
z = f(c) \\
f(x) = z
\end{cases}
\Rightarrow
\begin{cases}
x = y = c \\
z = f(c)
\end{cases}
\end{equation*}
Тогда
\begin{equation*}
D_1 = (D_1' \lor L_1)\eta = (P(x) \lor R(y, z, f(x)))\eta = P(c) \lor R(c, f(c), f(c))
\end{equation*}

Проверить общезначимость формулы \(\varphi\) методом резолюций:
\begin{equation*}
\forall x (\forall y \exists v \forall u ((A(u, v) \to B(y, u)) \land (\lnot \exists w A(w, u) \to \forall z A(z, v))) \to \exists y B(x, y))
\end{equation*}

Покажем, что формула $\varphi_1 = \lnot \varphi$ противоречива. Построим для неё приведённую форму:
\begin{gather*}
\lnot \forall x (\forall y \exists v \forall u ((A(u, v) \to B(y, u)) \land (\lnot \exists w A(w, u) \to \forall z A(z, v))) \to \exists y B(x, y)) \\
\exists x \lnot (\forall y \exists v \forall u ((A(u, v) \to B(y, u)) \land (\lnot \exists w A(w, u) \to \forall z A(z, v))) \to \exists y B(x, y)) \\
\exists x (\forall y \exists v \forall u ((A(u, v) \to B(y, u)) \land (\lnot \exists w A(w, u) \to \forall z A(z, v))) \land \lnot \exists y B(x, y)) \\
\exists x (\forall y \exists v \forall u ((A(u, v) \to B(y, u)) \land (\forall w \lnot A(w, u) \to \forall z A(z, v))) \land \forall y \lnot B(x, y)) \\
\exists x (\forall y \exists v \forall u ((\lnot A(u, v) \lor B(y, u)) \land (\lnot \forall w \lnot A(w, u) \lor \forall z A(z, v))) \land \forall t \lnot B(x, t)) \\
\exists x (\forall y \exists v \forall u \forall t ((\lnot A(u, v) \lor B(y, u)) \land (\exists w A(w, u) \lor \forall z A(z, v)) \land \lnot B(x, t))) \\
\exists x \forall y \exists v \forall u \exists w \forall z \forall t ((\lnot A(u, v) \lor B(y, u)) \land (A(w, u) \lor A(z, v)) \land \lnot B(x, t))
\end{gather*}
Построим сколемовскую нормальную форму:
\begin{gather*}
\forall y \forall u \forall z \forall t ((\lnot A(u, f_1(y)) \lor B(y, u)) \land (A(f_2(y, u), u) \lor A(z, f_1(y))) \land \lnot B(c_1, t))
\end{gather*}
Получаем систему дизъюнктов:
\begin{gather*}
S = \{D_1, D_2, D_3\} \\
D_1 = \lnot A(u, f_1(y)) \lor B(y, u) \\
D_2 = A(f_2(y, u), u) \lor A(z, f_1(y)) \\
D_3 = \lnot B(c_1, t)
\end{gather*}
Применим к ней резолютивный вывод:
1. Склейка $D_2$:
\begin{equation*}
\begin{cases}
f_2(y_1, u_1) = z_1 \\
u_1 = f_1(y_1)
\end{cases}
\Rightarrow
\begin{cases}
z_1 = f_2(y_1, f_1(y_1)) \\
u_1 = f_1(y_1)
\end{cases}
\end{equation*}
Откуда получаем новый дизъюнкт:
\begin{equation*}
D_2 = A(f_2(y_1, f_1(y_1)), f_1(y_1))
\end{equation*}
2. Построим теперь резольвенту $D_1$ и $D_2$:
\begin{equation*}
\begin{cases}
u = f_2(y_1, f_1(y_1)), \\
f_1(y) = f_1(y_1)
\end{cases}
\Rightarrow
\begin{cases}
u = f_2(y_1, f_1(y_1)), \\
y = y_1
\end{cases}
\end{equation*}
Получим новую систему дизъюнктов:
\begin{gather*}
S = \{D_2', D_3\} \\
D_2' = B(y_1, f_2(y_1, f_1(y_1))) \\
D_3 = \lnot B(c_1, t)
\end{gather*}
3. Строим резольвенту $D_2'$ и $D_3$:
\begin{equation*}
\begin{cases}
y_1 = c_1, \\
f_2(y_1, f_1(y_1)) = t
\end{cases}
\Rightarrow
\begin{cases}
y_1 = c_1, \\
t = f_2(c_1, f_1(c))
\end{cases}
\end{equation*}
Получили, что $S \models \square$, что означает противоречивость формулы $\varphi_1$ и общезначимость формулы $\varphi$, что и требовалось доказать.

Привести к предварённой нормальной форме формулу:
\begin{equation*}
\lnot \forall y (\exists x P(x, y) \to \forall u (R(y, u) \to \lnot\forall z(P(z, u) \lor \lnot R(z, y))))
\end{equation*}

\begin{gather*}
\lnot \forall y (\exists x P(x, y) \to \forall u (R(y, u) \to \lnot\forall z(P(z, u) \lor \lnot R(z, y)))) \\
\lnot \forall y (\lnot \exists x P(x, y) \lor \forall u (\lnot R(y, u) \lor \lnot \forall z (P(z, u) \lor \lnot R(z, y)))) \\
\exists y (\exists x P(x, y) \land \exists u (\lnot R(y, u) \lor \exists z (\lnot P(z, u) \land R(z, y)))) \\
\exists x \exists y \exists u \exists z (P(x, y) \land (\lnot R(y, u) \lor (\lnot P(z, u) \lor R(z, y)))) \\
\exists x \exists y \exists u \exists z (P(x, y) \land (\lnot R(y, u) \lor \lnot P(z, u) \lor P(z, y)))
\end{gather*}

Провести сколемизацию формулы:
\begin{equation*}
\forall x \exists y \forall z \exists u R(x, y, z, u)
\end{equation*}

\begin{equation*}
\forall x \forall z R(x, f(x), z, g(x, z))
\end{equation*}

\begin{equation*}
\lnot \forall x (\exists y R(x, y) \to \forall z P(z, x))
\end{equation*}

\begin{gather*}
\exists x \exists y \exists z(R(x, y) \land \lnot P(z, x)) \\
R(c_1, c_2) \land \lnot P(c_3, c_1)
\end{gather*}

\begin{equation*}
\lnot \forall y (\exists x P(x, y) \to \forall u (R(y, u) \to \lnot \forall z (P(z, u) \lor \lnot R(z, y))))
\end{equation*}

\begin{gather*}
\exists x \exists y \exists u \exists z (P(x, y) \land (\lnot R(y, u) \lor \lnot P(z, u) \lor P(z, y))) \\
P(c_1, c_2) \land (\lnot R(c_2, c_3) \lor \lnot P(c_4, c_3) \lor P(c_4, c_2))
\end{gather*}

Решить задачу унификации:
\begin{equation*}
R(Z, f(X, g(U), h(Y))) = R(h(X), f(g(a), Y, Z))
\end{equation*}
\begin{equation*}
\begin{cases}
Z = h(X) \\
f(X, g(U), h(Y)) = f(g(a), Y, Z)
\end{cases}
\Rightarrow
\begin{cases}
Z = h(X) \\
X = g(a) \\
g(U) = Y \\
h(Y) = Z \\
\end{cases}
\Rightarrow
Z = h(g(a)) \\
X = g(a) \\
Y = g(a) \\
U = a
\end{equation*}
Таким образом, искомая подстановка имеет вид:
\begin{equation*}
\{X/g(a), Y/g(a), Z/h(g(a)), U/a\}
\end{equation*}

Найти НОУ для атомов:
\begin{equation*}
P(f(X, Y), Z, h(Z, Y)), P(f(Y, X), g(y), V)
\end{equation*}
\begin{equation*}
P(f(X, Y), Z, h(Z, Y)) = P(f(Y, X), g(Y), V) \Rightarrow
\begin{cases}
f(X, Y) = f(Y, X) \\
Z = g(Y) \\
h(Z, Y) = V
\end{cases}
\Rightarrow
\begin{cases}
X = Y \\
Z = g(Y) \\
V = h(Z, Y)
\end{cases}
\end{equation*}
\begin{equation*}
R(c, X, f(X)) = R(Z, Y, Y)
\Rightarrow
\begin{cases}
Z = c \\
X = Y \\
Y = f(Y)
\end{cases}
\end{equation*}
решения нет.
\begin{equation*}
P(X, Y, Z, U, V) = P(f(Y, Y), f(Z, Z), f(U, U), f(V, V), f(c, d))
\Rightarrow
\begin{cases}
X = f(Y, Y) \\
Y = f(Z, Z) \\
Z = f(U, U) \\
U = f(V, V) \\
V = f(c, d)
\end{cases}
\Rightarrow
\begin{cases}
X = \ldots \\
Y = \ldots \\
Z = f(f(f(c, d), f(c, d)), f(f(c, d), f(c, d))) \\
U = f(f(c, d), f(c, d)) \\
V = f(c, d)
\end{cases}
\end{equation*}
Построить резольвенты для дизъюнктов:
\begin{equation*}
\begin{cases}
D_1 = \lnot P(f(X_1, Y_1), Z_1, h(Z_1, Y_1)) \lor R(Z_1, V_1) \\
D_2 = Q(X_2) \lor P(f(Y_2, X_2), g(Y_2), V_2)
\end{cases}
\end{equation*}
Вычислим НОУ для контрарной пары:
\begin{equation*}
P(f(X_1, Y_1), Z_1, h(Z_1, Y_1)) = P(f(Y_2, X_2), g(Y_2), V_2)
\Rightarrow
\begin{cases}
f(X_1, Y_1) = f(Y_2, X_2) \\
Z_1 = g(Y_2) \\
h(Z_1, Y_1) = V_2
\end{cases}
\Rightarrow
\begin{cases}
X_1 = Y_2 \\
Y_1 = X_2 \\
Z_1 = g(Y_2) \\
V_2 = h(g(Y_2), X_2)
\end{cases}
\end{equation*}
Получаем резольвенту:
\begin{equation*}
D = R(g(Y_2), V_1) \lor Q(X_2)
\end{equation*}
\begin{minted}[]{text}
родитель(X, Y) <- мать(X, Y)
родитель(X, Y) <- отец(X, Y)
\end{minted}
или
\begin{minted}[]{text}
родитель(X, Y) <- мать(X, Y) | отец(X, Y)
\end{minted}
\begin{minted}[]{text}
дед(X, Y) <- отец(X, Z), родитель(Z, Y)
\end{minted}
\begin{minted}[]{text}
сестра(X, Y) <- женщина(X), родитель(Z, X), родитель(Z, Y), X ≠ Y
\end{minted}
\begin{minted}[]{text}
потомок(X, Y) <- родитель(Y, X) | потомок(X, Z), родитель(Y, Z)
\end{minted}
\begin{minted}[]{text}
list(nil) <-
list(X.Y) <- list(Y)
\end{minted}
\begin{minted}[]{text}
elem(X, X.Z) <-
elem(X, Y.Z) <- elem(X, Z)
\end{minted}
\begin{minted}[]{text}
nonelem(X, nil) <-
nonelem(X, Y.L) <- non_eq(X, Y), nonelem(X, L)
\end{minted}
\begin{minted}[]{text}
no_common(nil, L2) <-
no_common(X.L, L2) <- non_elem(X, L2), no_common(L, L2)
\end{minted}
\begin{minted}[]{text}
single(nil, nil) <-
single(X.L, Y.L1) <- single(L, L1), elem(X, L1)
single(X.L, Y.L1) <- single(L, X.L1), nonelem(X, L1)
\end{minted}
\begin{minted}[]{text}
union(nil, L, L) <-
union(x.L, L2, L3) <- elem(x, L2), union(L, L2, L3)
union(x.L, L2, x.L3) <- nonelem(x, L2), union(L, L2, L3)
\end{minted}
\begin{minted}[]{text}
intersect(nil, L, nil) <-
intersect(x.L, L2, x.L3) <- elem(x, L2), intersect(L, L2, L3)
intersect(x.L, L2, L3) <- nonelem(x, L2), intersect(L, L2, L3)
\end{minted}
\begin{minted}[]{text}
differ(L, nil, L) <-
differ(L1, x.L2, x.L3) <- nonelem(x, L1), differ(L1, L2, L3)
differ(L1, x.L2, L3) <- elem(x, L1), differ(L1, L2, L3)
\end{minted}
\begin{minted}[]{text}
ordered(nil) <-
ordered(X.nil) <-
ordered(X.Y.L) <- X <= Y, ordered(L)
\end{minted}
\begin{minted}[]{text}
max(X.nil, X) <-
max(X.L, X) <- max(L, Y), Y <= X
max(X.L, Y) <- max(L, Y), Y > X
\end{minted}
\begin{minted}[]{text}
max(Y.L, X) <- max3(L, Y, X)
max3(nil, V, V) <-
max3(V.L, U, X) <- U < V, max3(L, V, X)
max3(V.L, U, X) <- V <= U, max3(L, U, X)
\end{minted}
\begin{minted}[]{text}
merge_sort(nil, nil) <-
merge_sort(L1, L2) <- divide(L1, L3, L4), merge_sort(L3, L5), merge_sort(L4, L6), merge(L5, L6, L7)

merge(L, nil) <- L
merge(nil, L) <- L
merge(X.L1, Y.L2, X.L3) <- X < Y, merge(L1, Y.L2, L3)
merge(X.L1, Y.L2, Y.L3) <- X >= Y, merge(X.L1, L2, L3)

divide(nil, nil, nil) <-
divide(X.nil, X.nil, nil) <-
divide(X.Y.L, X.L1, Y.L2) <- divide(L, L1, L2)
\end{minted}
\begin{minted}[]{text}
len(L, Z) <- lenAcc(L, 0, Z)
lenAcc(nil, A, A) <-
lenAcc(X.L, A, B) <- C is A + 1, lenAcc(L, C, B)
\end{minted}
\begin{minted}[]{text}
sum(Y.L, X) <- sumAcc(L, Y, X)
sumAcc(nil, S, S) <-
sumAcc(X.L, A, B) <- S is X + A, sumAcc(L, S, B)
\end{minted}
\begin{minted}[]{text}
mult(L, U, X) <- multAcc(L, U, X, 0)
multAcc(nil, U, A, A) <-
multAcc(U.L, U, X, A) <- N is A + 1, multAcc(L, U, X, N)
multAcc(Y.L, U, X, A) <- V != U, multAcc(L, U, X, A)
\end{minted}
\begin{minted}[]{text}
most_freq(Y.nil, Y) <-
most_freq(Y.L, X) <- mult(Y.L, Y, N), most_freq(L, Z),
                     mult(L, Z, M), decide(Y, N, M, Z, X)
decide(Y, N, Z, M, Z) <- N < M
decide(Y, N, Z, M, Y) <- M <= N
\end{minted}
\begin{minted}[]{text}
max(X, Y, X) <- X > Y, !
max(X, Y, Y) <-
\end{minted}
\begin{minted}[]{text}
common(nil, L, nil) <-
common(Y.L1, L2, Y.L3) <- elem(Y, L2), !, common(L1, L2, L3)
common(Y.L1, L2, L3) <- common(L1, L2, L3)
\end{minted}
\begin{minted}[]{text}
nonsquare(L, X) <- nonsquare3(L, L, X)
nonsquare3(nil, L, nil) <-
nonsquare3(X.L, L1, X) <- Z is Y * Y, elem(Z, L), !nonsquare3(L, L1, X)
nonsquare3(X.L, L1, X.D) <- nonsquare3(L, L1, D)
\end{minted}
\begin{minted}[]{text}
max(L, X) <- not(exists_greater(X, L))
exists_greater(X, L) <- Y > X, elem(Y, L)
\end{minted}
\begin{minted}[]{text}
filter_greater3(nil, nil) <-
filter_greater3(X.L1, X.L2) <- X > 3, filter_greater3(L1, L2)
filter_greater3(X.L1, L2) <- X <= 3, filter_greater3(L1, L2)
\end{minted}
\begin{minted}[]{text}
triplets(nil, nil) <-
triplets(X.nil, nil) <-
triplets(X.Y.nil, nil) <-
triplets(L, (X.Y.Z).R) <- X < Y, Y < Z, elem(X, L), elem(Y, L), elem(Z, L)
\end{minted}
\end{document}
